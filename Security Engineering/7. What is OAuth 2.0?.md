
OAuth was originally developed to enable a user of a service to allow a 3rd party service to access their data without disclosing their password. For example, OAuth 2.0 enables a Gmail user to securely grant Zoom access to their calendar. The outcome of the authorization process, which is officially known as a flow, is an access token being issued to the 3rd party application. The 3rd party application - e.g., Zoom - includes that token in the request to the service’s API - e.g., Gmail - which uses the token to authorize the request. Let’s look at how tokens are issued.

An authorization flow involves the following four parties:

- Resource Owner - user that wants to grant the Client access to their data
- Client - 3rd party application, such as Zoom
- Resource server - the API that the user wants the Client to access, such as the Google calendar API
- Authorization Server - authenticates users and issues access tokens, which the client presents to the resource server

The following diagram shows at a high level how these four parties collaborate to grant access:

![OAuth2-Simplified-Flow](OAuth2-Simplified-Flow.png)

Without getting into the details, the flow for issuing an access token for a browser-based UI works something like this:

1. To obtain access to the resource server, the client redirects the user’s browser to the Authorization Server’s authorization endpoint.
2. If the user is not already logged into the Authorization Server, the user enters their credentials, and the Authorization Server validates them.
3. The user confirms that the Authorization Server should grant the Client access.
4. The authorization server redirects the browser to the client’s redirection endpoint.
5. The client’s redirection endpoint’s handler invokes the authorization server’s token endpoint to obtain an access token, which grants access to the resource server

---
### Access Tokens

There are two types of access tokens: opaque and transparent. An opaque token is a random sequence of characters. In order to authorize a request containing an opaque token, the resource server must invoke the authorization server to decode the token. A transparent token contains information in a format that the resource server can decode. It eliminates the overhead of a roundtrip to the authorization server.

Modern OAuth 2.0 authorization servers typically issue transparent access tokens in the form of JSON web tokens (JWTs). A JWT is a signed JSON document containing a set of claims - key-value pairs containing information about the user and the token itself. A client’s permissions are represented as claims within the JWT. JWTs are typically signed using an asymmetric algorithm, which uses a private key only known to the authorization server. To validate a JWT, a resource server can - on startup - retrieve the corresponding public key from the authorization server using its JWKS endpoint.

One drawback of JWT-based access tokens is that anyone who possesses one can access the resource server. Unlike with opaque tokens, the resource server does not contact the authorization server to validate a JWT; it verifies the token locally.

**Authorization servers typically issue JWT access tokens with a short expiration time to limit the impact of token theft. To avoid forcing the resource owner to repeatedly authenticate, the authorization server also issues a long-lived refresh token, which the client can use to obtain new access tokens as needed.** 

The client should store the refresh token securely, as it grants ongoing access. A client can revoke a refresh token by making a request to the authorization server’s token revocation endpoint.