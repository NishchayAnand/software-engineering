
`Feign` is a declarative `REST` client. This means that instead of writing a lot of boilerplate code (like using `RestTemplate` or `WebClient`), you simply define a `Java` interface, and `Feign` automatically generates the `HTTP` calls for you.

**Spring Cloud OpenFeign** integrates `Feign` with the `Spring` ecosystem, making it super easy to call other microservices in your system.

---
### How it Works?

Normally, if Service A needs to call Service B’s REST API, you would:

- Write code with RestTemplate or WebClient
- Handle serialization/deserialization manually
- Manage URLs, headers, etc.

With **OpenFeign**, you just define an interface like this:

```
@FeignClient(name = "inventory-service", url = "http://inventory-service")
public interface InventoryClient {

    @GetMapping("/inventory/{hotelId}")
    InventoryResponse getInventory(@PathVariable("hotelId") String hotelId);
}
```

Now in your service, you can inject and use it just like a normal Spring bean:

```
@Service
public class HotelService {
    
    private final InventoryClient inventoryClient;

    public HotelService(InventoryClient inventoryClient) {
        this.inventoryClient = inventoryClient;
    }

    public InventoryResponse fetchInventory(String hotelId) {
	    // Feign makes the REST call automatically
        return inventoryClient.getInventory(hotelId);
    }
}
```

---
### What is @EnableFeignClients Annotation?

The @EnableFeignClients annotation is what tells Spring Boot to activate and scan for Feign client interfaces in your project.

---
### Default Exception Propagation Strategy

The Feign client makes interactions between microservices straightforward and highly configurable, using annotations and configuration properties. However, API calls might fail due to any random technical reason, bad user requests, or coding errors.

Fortunately, **Feign and Spring have a sensible default implementation** for error handling.

Feign uses the `ErrorDecoder.Default` class for its error handling. With this, whenever Feign receives any **non-2xx status code**, it passes that to the **ErrorDecoder’s decode method**. 

The decode method either returns a `RetryableException` if the HTTP response had a `Retry-After` header or it returns a `FeignException` otherwise. 

When retrying, if the request fails after the default number of retries, then the `FeignException` will be returned.

The **decode method stores the HTTP method key and response** in the FeignException.

---
### Propagating Custom Exceptions in Feign With the ErrorDecoder

Instead of always returning the default `FeignException`, we should return some application-specific exceptions based on the HTTP status code.

Let’s override the decode method in a custom _ErrorDecoder_ implementation:

```
public class CustomErrorDecoder implements ErrorDecoder {

    @Override
    public Exception decode(String methodKey, Response response) {
        switch (response.status()){
            case 400:
                return new BadRequestException();
            case 404:
                return new ProductNotFoundException("Product not found");
            case 503:
                return new ProductServiceNotAvailableException("Product Api is 
													            unavailable");
            default:
                return new Exception("Exception while getting product details");
        }
    }
}
```

Now, let’s configure the `CustomErrorDecoder` in the FeignConfig as a Spring Bean:

```
@Configuration
public class FeignConfig {

	@Bean
	public ErrorDecoder errorDecoder() {
	   return new CustomErrorDecoder();
	}
	
}

@FeignClient(name = "product-client-2", url = "http://localhost:8081/product/", 
											configuration = { FeignConfig.class})
```

---


