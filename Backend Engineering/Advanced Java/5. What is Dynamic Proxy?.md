
A **Dynamic Proxy** is a way in Java to create proxy objects **at runtime**, without you writing a separate proxy class for each interface.

Instead of manually coding a `ProxyXYZ` class like in the classic **Proxy Pattern**, you let the JVM generate one dynamically using `java.lang.reflect.Proxy`.

---
### Why Dynamic Proxy?

- When you have many interfaces and don't want to create a separate proxy class for each.    
- To **add cross-cutting concerns** (logging, security, transaction management, etc.) without modifying the actual implementation.

---
### What are Invocation Handlers?



---


A framework reads these annotations (via **reflection**) and then uses **dynamic proxies** (JDK or CGLIB) to wrap your object with extra behavior **based on what the annotation says**.

```
@Service
public class MyService {
    @Transactional
    public void processData() { ... }
}
```

Here’s what happens under the hood:

1. Spring sees `@Transactional` on `processData()` during bean creation.
2. It decides: "This bean needs transaction handling."
3. Instead of returning your original `MyService` instance, Spring returns **a proxy object**:
    - If your class implements an interface → JDK **Dynamic Proxy**.
    - If it doesn’t → **CGLIB Proxy** (creates subclass).
4. The proxy intercepts calls to `processData()`:
    - Starts a transaction before the call.
    - Invokes the real method.
    - Commits or rolls back afterward.

You think you’re calling:

```
myService.processData();
```

But you’re actually calling:

```
proxy.processData() → extra logic → realObject.processData()
```