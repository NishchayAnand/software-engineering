
A **JDK Dynamic Proxy** allows you to create an object **at runtime** that implements one or more interfaces, and delegates method calls to an `InvocationHandler`.

**Example:**

```
interface PaymentService {
    void pay();
}

class PaymentServiceImpl implements PaymentService {
    public void pay() { System.out.println("Payment processed"); }
}
```

**We can create a proxy around it:**

```
PaymentService target = new PaymentServiceImpl();

PaymentService proxy = (PaymentService) Proxy.newProxyInstance(
    target.getClass().getClassLoader(),
    new Class[]{PaymentService.class},
    (proxyObj, method, args) -> {
        System.out.println("Before method: " + method.getName());
        Object result = method.invoke(target, args);
        System.out.println("After method: " + method.getName());
        return result;
    }
);

proxy.pay();
```

**Output:**

```
Before method: pay
Payment processed
After method: pay
```

**Key points:**

- Proxy implements `PaymentService`.
- Any call to proxy methods triggers the `InvocationHandler`.
- You can only proxy **interfaces**, not concrete classes.

---

A **Dynamic Proxy** is a way in Java to create proxy objects **at runtime**, without you writing a separate proxy class for each interface.

Instead of manually coding a `ProxyXYZ` class like in the classic **Proxy Pattern**, you let the JVM generate one dynamically using `java.lang.reflect.Proxy`.

---
### Why Dynamic Proxy?

- When you have many interfaces and don't want to create a separate proxy class for each.    
- To **add cross-cutting concerns** (logging, security, transaction management, etc.) without modifying the actual implementation.

---
### What are Invocation Handlers?



---


A framework reads these annotations (via **reflection**) and then uses **dynamic proxies** (JDK or CGLIB) to wrap your object with extra behavior **based on what the annotation says**.

```
@Service
public class MyService {
    @Transactional
    public void processData() { ... }
}
```

Here’s what happens under the hood:

1. Spring sees `@Transactional` on `processData()` during bean creation.
2. It decides: "This bean needs transaction handling."
3. Instead of returning your original `MyService` instance, Spring returns **a proxy object**:
    - If your class implements an interface → JDK **Dynamic Proxy**.
    - If it doesn’t → **CGLIB Proxy** (creates subclass).
4. The proxy intercepts calls to `processData()`:
    - Starts a transaction before the call.
    - Invokes the real method.
    - Commits or rolls back afterward.

You think you’re calling:

```
myService.processData();
```

But you’re actually calling:

```
proxy.processData() → extra logic → realObject.processData()
```