
The **Dependency Inversion Principle (DIP)** states that:

- **High-level modules should not depend on low-level modules. Both should depend on abstractions.** This simply means <span style="color:green;font-weight:bold;background:beige;">"All the code in your system should depend on abstractions (interfaces), not on concrete implementations"</span>. 

- **Abstractions should not depend on details. Details should depend on abstractions**. This means. This simply means <span style="color:green;font-weight:bold;background:beige;">"Instead of your abstractions (interfaces) depending on specific implementations, your implementations should depend on interfaces"</span>. 

<span style="color:purple;font-weight:bold;">Bad Design</span>

In a traditional setup, you might see something like this:

```
interface Database {
    void save(String data);
}

class MySQLDatabase implements Database {
    public void save(String data) {
        // Write to MySQL
    }
}

class PostgreSQLDatabase implements DataStore {
    public void save(String data) {
        // Write to PostgreSQL
    }
}
```

```
class ReportService {
    Database db = new MySQLDatabase();  // implementation tightly coupled!

	void generateReport(String data) {
        db.save(data);
    }
}
```

*Here:*
- *`ReportService` is a high-level module (business logic).*
- *`MySQLDatabase` is a low-level module (technical detail).*

Even though we're using the **`Database`** interface, the **`ReportService`** is still directly instantiating a concrete class, i.e., <span style="color:green;font-weight:bold;background:beige;">the high-level module is directly depending on the low-level module</span>. 

If we want to switch to `PostgreSQLDatabase`, we **can't** without modifying `ReportService`.

<span style="color:purple;font-weight:bold;">Solution</span>

Rather than instantiating the dependency (`Database db`) inside the `ReportService` class, provide it from outside by passing it through the constructor.

```
class ReportService {
    private Database db;

    ReportService(Database db) {
        this.db = db;
    }

    void generateReport(String data) {
        db.save(data);
    }
}
```

This approach allows `ReportService` to depend only on the abstraction: `Database`, making it flexible, decoupled, and compliant with the **Dependency Inversion Principle**.

---
### What is Dependency Injection?

**Dependency Injection (DI)** is a design pattern used to implement **DIP in object-oriented programming**. 

In DI, high-level classes (**consumers**) do not create or manage the objects they depend on. Instead, they simply declare the interfaces (abstractions) they require. 

The responsibility of creating and supplying the actual implementations of these dependencies is delegated to a separate component, commonly known as the **injector**. This injector injects the dependency objects into the consumer at runtime, ensuring that the consumer receives the exact dependency it needs without being concerned with how it is created or managed (**loosely coupled**). 

<span style="color:purple;font-weight:bold;">Ways to Implement Dependency Injection</span>

| Type                      | How It Works                                       | When to Use                                                                                               |
| ------------------------- | -------------------------------------------------- | --------------------------------------------------------------------------------------------------------- |
| **Constructor Injection** | Pass the dependency via the class constructor.     | When the dependency is required for the object to function (**best practice**).                           |
| **Setter Injection**      | Pass the dependency via a public setter method.    | When the dependency is optional or may change after object creation.                                      |
| **Field Injection**       | Inject the dependency directly into a class field. | Often used with frameworks (e.g., Spring), but **not recommended for pure OOP as it hides dependencies.** |

---
## EXTRA

This principle enforces the use of **Abstract Factories**, i.e., `Factory Pattern` promotes Dependency Inversion Principle.

**Example**

```
// Abstraction (Interface)
interface PaymentGateway {
    void processPayment(double amount);
}
```

```
// Concrete implementation of PaymentGateway for PayPal
class PayPalGateway implements PaymentGateway {
    @Override
    public void processPayment(double amount) {
        // Code to process payment via PayPal
        System.out.println("Processing payment of $" + amount + " via PayPal");
    }
}
```

```
// High-level class that depends on PaymentGateway abstraction
class PaymentProcessor {
    private PaymentGateway paymentGateway;

    // Constructor injection of PaymentGateway
    public PaymentProcessor(PaymentGateway paymentGateway) {
        this.paymentGateway = paymentGateway;
    }

    public void processPayment(double amount) {
        // Delegate payment processing to the injected PaymentGateway
        paymentGateway.processPayment(amount);
    }
}
```

In the above example:

- `PaymentGateway` is the interface representing the abstraction for payment processing.
- `PayPalGateway` is a concrete implementation of `PaymentGateway`.
- `PaymentProcessor` is a high-level class that depends on `PaymentGateway` abstraction.

The `PaymentProcessor` accepts an instance of `PaymentGateway` via constructor injection. It is unaware of the specific implementation details of the payment processing (e.g., PayPal) and only depends on the abstraction `PaymentGateway`.

You can easily swap out the concrete implementation of `PaymentGateway` (e.g., replace PayPal with Stripe) without modifying the `PaymentProcessor` class, thus adhering to the Dependency Inversion Principle.

---

