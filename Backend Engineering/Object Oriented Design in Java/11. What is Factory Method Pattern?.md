
<span style="color:green;font-weight:bold;background:beige;">Developers can unknowingly create objects directly in ways that can lead to scattered dependencies across the codebase</span>, making the system harder to maintain and evolve. Any change to the way an object is instantiated forces multiple updates across different parts of the system.

Even when we follow the **Dependency Inversion Principle** and inject dependencies into clients rather than instantiating them directly, the creation of those dependencies still happens somewhere.

**Example**

```
interface DatabaseConnection {
    void connect();
}
```

```
class MySQLConnection implements DatabaseConnection {
    
    String host;
    int port;
    String username;
    String password;

    MySQLConnection(String host, int port, String username, String password) {
        this.host = host;
        this.port = port;
        this.username = username;
        this.password = password;
    }

	@Override
    void connect() {
        System.out.println("Connecting to MySQL at " + host + ":" + port);
    }
    
}
```

```
// client 1
class UserService {
    
    private DatabaseConnection connection;

    UserService(DatabaseConnection connection) {  // Dependency is injected here
        this.connection = connection;
    }

    void getUserDetails() {
        connection.connect();
        System.out.println("Fetching user details...");
    }
    
}
```

```
// client 2
class OrderService {
    
    private DatabaseConnection connection;

    OrderService(DatabaseConnection connection) {  // Dependency is injected here
        this.connection = connection;
    }

    void createOrder() {
        connection.connect();
        System.out.println("Creating order...");
    }
    
}
```

```
class Client {
    public static void main(String[] args) {
        
        DatabaseConnection connection = new MySQLConnection("localhost", 3306,                                                               "root", "admin123");

        UserService userService = new UserService(connection);
        userService.getUserDetails();

        OrderService orderService = new OrderService(connection);
        orderService.createOrder();
        
    }
}
```

<span style="color:green;font-weight:bold;background:beige;">When the</span> **`Client`** <span style="color:green;font-weight:bold;background:beige;">code directly instantiates the</span> **`MySQLConnection`** <span style="color:green;font-weight:bold;background:beige;">concrete class, it becomes tightly coupled to that specific implementation</span>. This makes the code fragile and harder to maintain because:

- If the constructor parameters of **`MySQLConnection`** change, the **`Client`** must also change.
- If you want to switch to a different database (like **`PostgreSQLConnection`**), you must modify the **`Client`** code.

---
### What is a Factory?

In software design, a **factory** refers to anything responsible for creating objects. 

The main idea behind using a factory is to **encapsulate the creation logic** so that the client code (the part of the application using the objects) doesn't need to know the details of how those objects are instantiated.

**Example**

```
class DatabaseConnectionFactory {

    public static DatabaseConnection getConnection(String type) {
        
        if (type.equalsIgnoreCase("mysql")) {
            return new MySQLConnection();
        } else if (type.equalsIgnoreCase("postgresql")) {
            return new PostgreSQLConnection();
        }
        
        throw new IllegalArgumentException("Unsupported database type");
        
    }
}
```

```
class Client {
    public static void main(String[] args) {

        DatabaseConnection connection = DatabaseConnectionFactory.                                                                        getConnection("mysql");

        OrderService orderService = new OrderService(connection);
        orderService.createOrder();
        
    }
}
```

In this design, the object creation logic is entirely handled by the **`DatabaseConnectionFactory`**, keeping the client free from any knowledge of how the connection is instantiated.

> **NOTE:** The objects are still created via the new operator, but it’s being called from within the factory method. Objects returned by a factory method are often referred to as products.

This separation allows you to switch to a different database (like **`PostgreSQLConnection`**) without making any changes to the client code. As a result, the system becomes easier to maintain, extend, and test.

```
class Client {
    public static void main(String[] args) {

        // Switching to PostgreSQL — no client code change required!
        DatabaseConnection pgConnection = DatabaseConnectionFactory.                                                                 getConnection("postgresql");

        OrderService orderService = new OrderService(pgConnection);
        orderService.createOrder();
        
    }
}
```

> **NOTE:** In a real-world application, instead of hardcoding `"mysql"` or `"postgresql"` in your code, you would typically read this value from a **configuration file**. This allows you to switch between different database types by simply changing the configuration.

This simple factory design works well when there are only a few types to manage, but as more database types are added, the **`getConnection()`** method can grow large, cluttered, and harder to maintain. 

Each new type requires updating the factory's logic, which directly violates the **Open / Closed Principle**.

---
### Factory Method Pattern

The **Factory Method Pattern** shifts the object creation responsibility from a single factory class to individual subclasses, each responsible for creating a specific type of object.

Instead of having one large method (e.g., `getConnection()` ) handling all types with `if-else` or `switch` statements, the pattern defines a common factory interface (or abstract class) with an abstract factory method (e.g., `createConnection()`), and each concrete factory subclass implements this method to create its specific type.

**Example**

```
abstract class ConnectionFactory {
    abstract DatabaseConnection createConnection();
}
```

```
class MySQLConnectionFactory extends ConnectionFactory {
    public DatabaseConnection createConnection() {
        return new MySQLConnection();
    }
}

class PostgreSQLConnectionFactory extends ConnectionFactory {
    public DatabaseConnection createConnection() {
        return new PostgreSQLConnection();
    }
}
```

```
class Client {
    public static void main(String[] args) {
        
        // Using MySQL factory
        ConnectionFactory mysqlFactory = new MySQLConnectionFactory();
        DatabaseConnection mysqlConnection = mysqlFactory.createConnection();
        mysqlConnection.connect();

        // Using PostgreSQL factory
        ConnectionFactory postgresFactory = new PostgreSQLConnectionFactory();
        DatabaseConnection postgresConnection = postgresFactory.                                                                            createConnection();
        postgresConnection.connect();
        
    }
}
```

This way, when a new database type needs to be supported, you don’t need to modify the existing factories or client code. Instead, you simply create a new factory subclass (e.g., `OracleConnectionFactory`) that implements the `createConnection()` method.

> **NOTE:** **Factory Method Pattern** fully adheres to the **Open / Closed Principle** because your system is **open for extension** (you can add new types by extending it) but **closed for modification** (no changes needed in the existing working code).

---
