
In real-world applications, it's common to design classes with a combination of **required attributes** and **optional attributes**. A common approach to handle this is by providing multiple overloaded constructors for every possible combination of attributes. 

However, as the number of optional attributes grows, this leads to the **telescoping constructor anti-pattern**, where constructors become increasingly complex, numerous, and hard to manage.

**Example**

```
class User {
    private String username;
    private String email;
    private String phone;
    private String address;

    public User(String username) {
        this.username = username;
    }

    public User(String username, String email) {
        this(username);
        this.email = email;
    }

    public User(String username, String email, String phone) {
        this(username, email);
        this.phone = phone;
    }

    public User(String username, String email, String phone, String address) {
        this(username, email, phone);
        this.address = address;
    }
}
```

Using multiple overloaded constructors to create instances of classes with a large number of optional attributes is not a good design strategy. 

We can use setter methods to avoid constructor overloads, but this approach has a major downside. <span style="color:green;font-weight:bold;background:beige;">It spreads the object construction across multiple method calls and provides no mechanism to ensure that all required attributes are set.</span> As a result, there's a risk that the object may be left in an incomplete or invalid state, leading to potential runtime issues and inconsistent behaviour.

**Example**

```
class User {
    private String username;  // required
    private String email;
    private String phone;
    private String address;

    public void setUsername(String username) { this.username = username; }
    public void setEmail(String email) { this.email = email; }
    public void setPhone(String phone) { this.phone = phone; }
    public void setAddress(String address) { this.address = address; }
}
```

```
// Client code
User user = new User();
user.setEmail("nish@example.com");  // Forgot to set username (required)
```

Instead of calling a big constructor with many parameters or setting properties one by one, you use the **Builder Pattern** to gradually set values in a controlled manner.

---
### How to Apply Builder Pattern?

The **Builder Pattern** offers a solution to the problem of constructing classes with many attributes, especially if they are optional. 

The idea is to separate the object construction logic from its representation. Instead of having the object manage its own complex construction logic, a separate **Builder class** takes responsibility for collecting all necessary data, setting values, and validating inputs if needed.

Once the data is prepared, the builder can create the final object in a single step. 

**Example**

```
class User {
	private String username;   // required
    private String email;
    private String phone;
    private String address;

    public User(Builder builder) {
        this.username = builder.username;
        this.email = builder.email;
        this.phone = builder.phone;
        this.address = builder.address;
    }

	public void setUsername(String username) { this.username = username; }
    public void setEmail(String email) { this.email = email; }
    public void setPhone(String phone) { this.phone = phone; }
    public void setAddress(String address) { this.address = address; }
}
```

```
public class UserBuilder {
    private final String username;  // required
    private String email;
    private String phone;
    private String address;

    public UserBuilder(String username) {
        this.username = username;
    }

    public UserBuilder email(String email) {
        this.email = email;
        return this;
    }

    public UserBuilder phone(String phone) {
        this.phone = phone;
        return this;
    }

    public UserBuilder address(String address) {
        this.address = address;
        return this;
    }

    public User build() {
        return new User(this);
    }
}
```

```
// Client code
User user = new UserBuilder("nish")
                .email("nish@example.com")
                .phone("1234567890")
                .build();
```

This leads to a cleaner and more modular design where the construction logic is decoupled from the business logic, making the codebase easier to read, maintain, and extend.

> **NOTE:** By separating the construction logic into a dedicated **`UserBuilder`** class, the **Builder Pattern** enforces the **Single Responsibility Principle (SRP)**. 

---
### How to Create Immutable Objects With Builder Pattern?

The **Builder pattern** is a cornerstone for creating immutable objects in Java, particularly when those objects are complex or have many optional parameters.

---

make the constructor private, make all instance fields private, remove all setter methods, add Builder as static inner class,




- _mmuable_ type, which means its value does not change after it is created.

Here's how to apply the builder pattern:

1. First, make the `UdacisearchClient` constructor `private` instead of `public`.
2. Next, make all the instance fields `final` and remove all the setter methods, such as `UdacisearchClient#setId(int)`. Congratulations, `UdacisearchClient` is now an immutable type — but it's no good if we can't instantiate it! Don't forget to delete the default values of the fields.
3. Give `UdacisearchClient` a static inner class called `Builder`. Give the builder class a non-`final` instance field corresponding to each field of `UdacisearchClient`.
4. Create setter methods for all the builder's fields. Each method should return a reference to the `Builder` itself (_i.e._, `this`).
5. Finally, add a `UdacisearchClient.Builder#build()` method that calls the now-`private` `UdacisearchClient` constructor.
6. Try out `UdacisearchClient.Builder` in `Main.java` by constructing the `client` variable with the new `Builder` class:`javac Main.java java Main`

---

