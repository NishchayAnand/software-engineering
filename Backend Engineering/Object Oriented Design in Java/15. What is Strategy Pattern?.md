
When you mix **changing behavior** and **stable behavior** inside the same class, that class becomes rigid and harder to maintain.

**Example**

```
public class PaymentGateway {
    public void processPayment(String paymentMethod, double amount) {
        if (paymentMethod.equals("creditcard")) {
            System.out.println("Paid " + amount + " using Credit Card");
        } else if (paymentMethod.equals("paypal")) {
            System.out.println("Paid " + amount + " using PayPal");
        } else if (paymentMethod.equals("upi")) {
            System.out.println("Paid " + amount + " using UPI");
        } else {
            throw new IllegalArgumentException("Unsupported payment type");
        }
    }
}
```

In the `PaymentGateway` class, the logic for **how payments are processed (changing behavior)** can evolve over time. However, general action of **processing a payment (stable behavior)** remains the same.

By mixing these concerns, the `PaymentGateway` class is violating two fundamental software design principles:

- **Single Responsibility Principle (SRP)**: It takes on multiple responsibilities within the same class. First, it is responsible for **processing the payment**, which should be its primary task. Second, it handles the logic for **deciding which payment method to use** by checking the type of payment within conditional statements. Third, it directly contains the **execution logic for each payment method**, embedding the specific steps required to perform each type of payment.

- **Open-Closed Principle (OCP)**: Every time a new payment method is introduced, you must modify the existing class, which increases the risk of breaking existing functionality.

> **NOTE:** Identify **stable behavior** as **"what always happens"** in your business process, and **changing behavior** as **"how it happens"** that may differ or grow over time.

---
### Good Design: Separate Changing Behavior from Stable Behavior

**Separating concerns** keeps classes focused on a single responsibility, making the system easier to understand, test, maintain, and extend.

The **Strategy Pattern** allows you to <span style="color:green;font-weight:bold;background:beige;">encapsulate changing behavior in separate strategy classes (e.g., different payment methods) and delegate execution to them, enabling the main class to focus solely on stable behavior (e.g., processing the payment)</span>.

> **NOTE:** If a class or method handles **multiple ways of doing something**, especially with lots of conditions, that behavior is a good candidate for a **Strategy**.

---
### How to Apply Strategy Pattern?

To apply the **Strategy Pattern**, extract the changing behavior into a common interface, implement different strategies for each variant, and delegate execution to the strategy via the main class (context).

**Example**

In the `PaymentGateway` class, the **way payments are processed** differs by payment method, so you can define a `PaymentStrategy` interface with a common `pay()` method. This allows each payment method to implement its specific logic separately.

```
public interface PaymentStrategy {
    void pay(double amount);
}
```

```
public class CreditCardPayment implements PaymentStrategy {
    @Override
    public void pay(double amount) {
        System.out.println("Paid " + amount + " using Credit Card");
    }
}

public class PayPalPayment implements PaymentStrategy {
    @Override
    public void pay(double amount) {
        System.out.println("Paid " + amount + " using PayPal");
    }
}
```

Refactor the `PaymentGateway` class to **delegate payment execution** to the `PaymentStrategy` interface, adhering to the **Dependency Inversion Principle (DIP)**. 

```
public class PaymentGateway {
    private final PaymentStrategy paymentStrategy;

    public PaymentProcessor(PaymentStrategy paymentStrategy) {
        this.paymentStrategy = paymentStrategy;
    }

    public void processPayment(double amount) {
        paymentStrategy.pay(amount);
    }
}
```

This decouples the stable behavior (processing the payment) from the changing behavior (how the payment is made), making the system more flexible, extensible, and maintainable.

---
### Real-Life Analogy

Imagine a **payment gateway app** that initially sets the payment method to **Credit Card**,  
but based on user choice later, switches to **UPI**, **without creating a new payment gateway object.**

```
PaymentGateway gateway = new PaymentGateway(new CreditCardPayment());
gateway.processPayment(500);   // Paid $500 using Credit Card

// Later, user changes the payment method to PayPal at runtime
gateway.setStrategy(new PayPalPayment());
gateway.processPayment(300);   // Paid $300 using PayPal
```

---
