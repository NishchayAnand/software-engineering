
The **Singleton Pattern** is a design convention that ensures <span style="color:green;font-weight:bold;background:beige;">"A class has only one instance throughout the application's lifecycle. It provides a global point of access to that single instance, similar to a global variable, but with controlled object creation"</span>. 

Unlike global variables that are initialized at program start, the Singleton allows you to create the instance **only when it is first needed** (lazy initialization), promoting better resource management and ensuring controlled access across the application.

---
### Design Choice for Shared Resources

In many systems, certain objects, like a **database connection**, are shared across different modules and need to be accessed globally. Even if different parts of the system interact with separate tables, they typically connect to the **same database instance**. 

<span style="color:green;font-weight:bold;background:beige;">Since a database is a global resource, it’s logical and efficient to maintain only one shared instance of it throughout the application.</span> However, when every part of the system requires access to this shared resource, it’s often unclear **which component should be responsible for creating and managing the database connection**. 

The **Singleton Pattern** solves this problem by ensuring that only **one database instance exists** and is **shared across the entire system**. This promotes consistent behaviour, efficient resource utilization, and easier maintenance since all parts of the application access the same instance through a controlled access point.

---
### How to Apply Singleton Pattern?

The basic way to implement a Singleton class is by <span style="color:green;font-weight:bold;background:beige;">declaring its constructor as private</span> to prevent direct instantiation from outside the class, and <span style="color:green;font-weight:bold;background:beige;">exposing only one public method, commonly named</span>: **`getInstance()`**, to provide controlled access to the single, shared instance. 

**Example**

```
public final class Database { 
	private static Database database; 
	
	private Database() {} 
	
	public static Database getInstance() { 
		if (database == null) { 
			database = new Database(); 
			database.connect("/usr/local/data/users.db"); 
		} 
		return database; 
	} 
	
	private void connect(String url) { 
		// Connects to the remote database
	} 
	
	public static void main(String[] args) { 
		Database a = Database.getInstance(); 
		Database b = Database.getInstance(); 
		System.out.println(a == b); 
	} 
}
```

This approach is called **lazy initialization**, where the single instance of the class is created only when it is first requested through a public **`getInstance()`** method. 

---
### Thread Safety

Using the Singleton pattern in a multithreaded environment can be challenging because, without proper handling, <span style="color:green;font-weight:bold;background:beige;">multiple threads may simultaneously access the `getInstance()` method and create separate instances of the Singleton class</span>. This defeats the purpose of having a single shared instance. 

To prevent such issues, it’s essential to implement **thread-safety mechanisms** to ensure that only one instance of the Singleton is created, even when accessed concurrently by multiple threads.

---
### Common Thread-Safety Mechanisms

Here are the most common thread-safety mechanisms used in Singleton implementations:

<span style="color:purple;font-weight:bold;">Synchronized Method</span>

Make the `getInstance()` method **synchronized** so only one thread can execute it at a time.

**Example**

```
private static Database database;

...

public static synchronized Database getInstance() {
    if (database == null) {
        database = new Database();
    }
    return database;
}
```

This approach can cause performance overhead because the method is locked on every call.

<span style="color:purple;font-weight:bold;">Double-Checked Locking</span>

<span style="color:green;font-weight:bold;background:beige;">Synchronization is only necessary during the first call to</span> **`getInstance()`**, i.e., when the singleton instance is being created. After the instance has been initialized, all subsequent calls to **`getInstance()`** should simply return the already created instance.

To achieve this, we can use the **Double-Checked Locking** pattern. This approach involves checking whether the instance is `null` **before** entering the synchronized block. If it is `null`, the thread enters the synchronized block, and checks the instance again **inside** the block before creating it.  

**Example**

```
private static volatile Database database;

...

public static Database getInstance() {
    if (database == null) {         // First Check (without locking)
        synchronized (Database.class) {
            if (database == null) { // Second Check (with locking)
                database = new Database(); 
            }
        }
    }
    return database;
}
```

The **second check inside the synchronized block** ensures that **only the first thread** that acquires the lock will create the instance.

> **Q. Why use the `volatile` keyword?**
> 
> In Java, object creation is **not guaranteed to be atomic** due to instruction reordering by the compiler or CPU. 
> 
> This means another thread checking: `if (instance == null)` could see a **non-null reference** before the constructor has finished executing. That thread would access a **partially constructed object**, leading to unpredictable behaviour.
> 
> The **`volatile`** keyword ensures that writes to the **`database`** variable are completed **before** any thread can read it.

---


<span style="color:purple;font-weight:bold;">Summary</span>

| **Approach**                                 | **Lazy Initialization** | **Performance**                    | **Remarks**                                                   |
| -------------------------------------------- | ----------------------- | ---------------------------------- | ------------------------------------------------------------- |
| **Synchronized Method**                      | Yes                     | Slower due to method-level locking | Simple to implement but adds overhead on every access         |
| **Double-Checked Locking**                   | Yes                     | Better after initialization        | Needs `volatile` keyword; recommended for performance         |
| **Static Block Initialization**              | No                      | Efficient                          | Instance created at class loading time                        |
| **Bill Pugh Singleton (Static Inner Class)** | Yes                     | Highly Efficient                   | Recommended; lazy-loaded, thread-safe without synchronization |
| **Enum Singleton**                           | Yes (JVM controlled)    | Very Efficient                     | Simplest, handles serialization automatically                 |

---

1.  Do nothing if calling the getInstance method isn't causing substantial overhead for your application.

2.  Move to an eagerly created instance rather than a lazily created one.

    ```
    public class Singleton {

        private static Singleton uniqueInstance = new Singleton();

        private Singleton() {}

        public static Singleton getInstance() {
            return uniqueInstance;
        }

    }
    ```

    Using this approach, we rely on the JVM to create the unique instance of the Singleton when the class is load. **The JVM guarantees that the instance will be created before any thread accesses the static uniqueInstance variable**.

3.  Using an ENUM to create Singleton.

    ```
    public enum Singleton {
        UNIQUE_INSTANCE;
    }

    public class SingletonClient {
        public static void main(String args[]) {
            Singleton singleton = Singleton.UNIQUE_INSTANCE;
        }
    }
    ```

> **NOTE:** If you are using a large number of singletons in your application, you should take a hard look at your design. Singletons are meant to be used sparingly.

1. **Synchronized Method**: You can synchronize the getInstance() method to ensure that only one thread can access it at a time.

   ```
   public class Singleton {
        private static Singleton obj = null;

        private Singleton() {
            System.out.println("Creating an object of Singleton class");
        }

        public static synchronized Singleton getInstance() {
            if (obj == null) {
                obj = new Singleton();
            }
            return obj;
        }
   }
   ```

   The method is `synchronized`, which can lead to performance overhead since every call to getInstance() will be synchronized, even after the instance has been created.

2. **Double-Checked Locking**: To avoid the performance cost of synchronized methods, you can use double-checked locking. This ensures that synchronization happens only when the instance is null and is not required for every subsequent call to getInstance().

   ```
   public class Singleton {
        private static volatile Singleton obj = null;

        private Singleton() {
            System.out.println("Creating an object of Singleton class");
        }

        public static Singleton getInstance() {
            if (obj == null) {
                synchronized (Singleton.class) {
                    if(obj == null) {
                        obj = new Singleton();
                    }
                }
            }
            return obj;
        }
   }
   ```

   NOTE: The `volatile` keyword would ensure that the writes to obj are visible to all threads.

---

## EXTRA

- The intention of this pattern is to ensure a class only has one instance, providing a global point of access to it.

- In Java, the key to singleton pattern is restricting the access of who can call the constructor of a class.

- Constructors can have access modifiers. You can make the constructor private, so that no one will be able to call it except for the class that defines it. Then, the only way to get the instance of the class is have a static method to create it and return it.

```

Sample Code 1:
public class Calculator {
private static Calculator instance;

    private Constructor() {}

    public static Calculator getInstance() {
        if (instance == null) {
            instance = new Calculator();
        }
        return instance;
    }

}
Issue: Can result in multiple instances in multi-threaded environment. The multi-threading problem can be solved by making the getInstance() method synchronized, but this will have an impact in performance since we only need synchronize the access to the method once (the first time the instance is created).

Sample Code 2:
public class Calculator {
private static Calculator instance = new Calculator(); // --> instance gets created when the class is compile.

    private Calculator() {}

    public static Calculator getInstance() {
        return instance;
    }

}
Issue: The instance will always be created, we want it or not. What if the instance is expensive to create and no one uses it?

```

- A singleton provides a means to ensure that only one object instance of a class is created and referenced by clients accessing that class. Most often, singletons are defined for a particular process. However, means for defining singletons within a certain distributed processing domain can also be defined.

- Serialization, i.e., the process of storing the state of the class in the file system can also create multiple instances of the class.

- In Java, the most acceptable singleton implementation is through the use of `Enumerations` (as long as you need to extend from another class).

```

```

---
