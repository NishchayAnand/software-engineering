
The **Singleton Pattern** is a design convention that ensures <span style="color:green;font-weight:bold;background:beige;">"A class has only one instance throughout the application's lifecycle. It provides a global point of access to that single instance, similar to a global variable, but with controlled object creation"</span>. 

Unlike global variables that are initialized at program start, the Singleton allows you to create the instance **only when it is first needed** (lazy initialization), promoting better resource management and ensuring controlled access across the application.

---
### Design Choice for Shared Resources

In many systems, certain objects, like a **database connection**, are shared across different modules and need to be accessed globally. Even if different parts of the system interact with separate tables, they typically connect to the **same database instance**. 

<span style="color:green;font-weight:bold;background:beige;">Since a database is a global resource, it’s logical and efficient to maintain only one shared instance of it throughout the application.</span> However, when every part of the system requires access to this shared resource, it’s often unclear **which component should be responsible for creating and managing the database connection**. 

The **Singleton Pattern** solves this problem by ensuring that only **one database instance exists** and is **shared across the entire system**. This promotes consistent behaviour, efficient resource utilization, and easier maintenance since all parts of the application access the same instance through a controlled access point.

---
### How to Apply Singleton Pattern?

The basic way to implement a Singleton class is by <span style="color:green;font-weight:bold;background:beige;">declaring its constructor as private</span> to prevent direct instantiation from outside the class, and <span style="color:green;font-weight:bold;background:beige;">exposing only one public method, commonly named</span>: **`getInstance()`**, to provide controlled access to the single, shared instance. 

**Example**

```
public class Database {

	private static Database database; 
	
	private Database() {} 
	
	public static Database getInstance() { 
		if (database == null) { 
			database = new Database(); 
		} 
		return database; 
	}  

}
```

This approach is called **lazy initialization**, where the single instance of the class is created only when it is first requested through a public **`getInstance()`** method. 

---
### Thread Safety

Using the Singleton pattern in a multithreaded environment can be challenging because, without proper handling, <span style="color:green;font-weight:bold;background:beige;">multiple threads may simultaneously access the `getInstance()` method and create separate instances of the Singleton class</span>. This defeats the purpose of having a single shared instance. 

To prevent such issues, it’s essential to implement **thread-safety mechanisms** to ensure that only one instance of the Singleton is created, even when accessed concurrently by multiple threads.

---
### Common Thread-Safety Mechanisms

Here are the most common thread-safety mechanisms used in Singleton implementations:

<span style="color:purple;font-weight:bold;">Synchronized Method</span>

Make the `getInstance()` method **synchronized** so only one thread can execute it at a time.

```
public class Database { 

	private static Database database; 
	
	private Database() {} 
	
	public static synchronized Database getInstance() {
	    if (database == null) {
	        database = new Database(); 
	    }
	    return database;
	}
 
}
```

This approach can cause performance overhead because the method is locked on every call.

<span style="color:purple;font-weight:bold;">Double-Checked Locking</span>

<span style="color:green;font-weight:bold;background:beige;">Synchronization is only necessary during the first call to</span> **`getInstance()`**, i.e., when the singleton instance is being created. After the instance has been initialized, all subsequent calls to **`getInstance()`** should simply return the already created instance.

To achieve this, we can use the **Double-Checked Locking** pattern. This approach involves checking whether the instance is `null` **before** entering the synchronized block. If it is `null`, the thread enters the synchronized block, and checks the instance again **inside** the block before creating it. 

The **second check inside the synchronized block** ensures that **only the first thread** that acquires the lock will create the instance.

```
public class Database { 

	private static volatile Database database; 
	
	private Database() {} 
	
	public static Database getInstance() {
	    if (database == null) {         // First Check (without locking)
	        synchronized (Database.class) {
	            if (database == null) { // Second Check (with locking)
	                database = new Database();
	            }
	        }
	    }
	    return database;
	}
 
}
```

This approach ensures thread safety and lazy initialization but comes with several drawbacks. It introduces additional complexity due to its nested checks and synchronized blocks, making the code harder to read and maintain. 

A major concern is the risk of instruction reordering, which, if not handled with the **`volatile`** keyword, can result in threads seeing a partially constructed object.

> **NOTE:**
> 
> In Java, object creation is **not guaranteed to be atomic** due to instruction reordering by the compiler or CPU. 
> 
> This means another thread checking: `if (database == null)` could see a **non-null reference** before the constructor has finished executing. That thread would access a **partially constructed object**, leading to unpredictable behaviour.
> 
> The **`volatile`** keyword prevents instruction reordering and ensures that writes to the **`database`** variable are completed **before** any thread can read it.

<span style="color:purple;font-weight:bold;">Eager Initialization</span>

In Java, **class loading is guaranteed to be thread-safe**. The JVM uses internal synchronization to make sure that **only one thread performs the class initialization**. 

If multiple threads attempt to use a class at the same time before it’s initialized, **the JVM pauses the other threads** until the initialization is complete.

To leverage the JVM’s built-in class loading mechanism, we can use the **Eager Initialization** pattern. This approach involves creating the singleton instance as a **static final field** when the class is loaded. 

```
public class Database { 

	private static final Database database = new Database();
	
	private Database() {} 
	
	public static Database getInstance() {
	    return database;
	}
 
}
```

Since the JVM guarantees that class loading and static initialization are thread-safe, the **database instance** is safely created exactly once, even in a multithreaded environment. 

With this method, no explicit synchronization or additional code is required to ensure thread safety. The Singleton instance is readily available whenever needed. However, since the instance is created at class loading time, <span style="color:green;font-weight:bold;background:beige;">this pattern is best used when the Singleton is lightweight and expected to be used throughout the application</span>.

<span style="color:purple;font-weight:bold;">Bill Pugh Singleton</span>

If your Singleton manages a **heavy resource** like a database connection pool, remote configuration loader, or large cache, the **Eager Initialization** pattern may not be the right fit.

Eager Initialization creates the singleton instance **at the time of class loading**, regardless of whether it is actually used later. For resource-intensive operations, this can lead to **unnecessary memory consumption, increased startup time**, and wasted resources, especially if the Singleton is never used during the application's lifecycle.

In such cases, the **Bill Pugh Singleton pattern** is a much better choice. By placing the singleton instance inside a **`private static inner class`**, the JVM implicitly handles the thread safety of loading that inner class when the **`getInstance()`** method is called for the first time.

```
public class Database {

    private Database() { }

    private static class Holder {
        private static final Database INSTANCE = new Database();
    }

    public static Database getInstance() {
        return Holder.INSTANCE;
    }
}
```

This approach guarantees that the singleton instance is created **exactly once** in a **lazy and thread-safe manner**, without requiring explicit synchronization or `volatile`. 

<span style="color:purple;font-weight:bold;">Enum Singleton</span>



<span style="color:purple;font-weight:bold;">Summary</span>

| **Approach**                                 | **Lazy Initialization** | **Performance**                    | **Remarks**                                                   |
| -------------------------------------------- | ----------------------- | ---------------------------------- | ------------------------------------------------------------- |
| **Synchronized Method**                      | Yes                     | Slower due to method-level locking | Simple to implement but adds overhead on every access         |
| **Double-Checked Locking**                   | Yes                     | Better after initialization        | Needs `volatile` keyword; recommended for performance         |
| **Eager Initialization**                     | No                      | Efficient                          | Instance created at class loading time                        |
| **Bill Pugh Singleton (Static Inner Class)** | Yes                     | Highly Efficient                   | Recommended; lazy-loaded, thread-safe without synchronization |
| **Enum Singleton**                           | Yes (JVM controlled)    | Very Efficient                     | Simplest, handles serialization automatically                 |

---

> **NOTE:** If you are using a large number of singletons in your application, you should take a hard look at your design. Singletons are meant to be used sparingly.

---
### EXTRA

- The intention of this pattern is to ensure a class only has one instance, providing a global point of access to it.

- In Java, the key to singleton pattern is restricting the access of who can call the constructor of a class.

- Constructors can have access modifiers. You can make the constructor private, so that no one will be able to call it except for the class that defines it. Then, the only way to get the instance of the class is have a static method to create it and return it.

```

Sample Code 1:
public class Calculator {
private static Calculator instance;

    private Constructor() {}

    public static Calculator getInstance() {
        if (instance == null) {
            instance = new Calculator();
        }
        return instance;
    }

}
Issue: Can result in multiple instances in multi-threaded environment. The multi-threading problem can be solved by making the getInstance() method synchronized, but this will have an impact in performance since we only need synchronize the access to the method once (the first time the instance is created).

Sample Code 2:
public class Calculator {
private static Calculator instance = new Calculator(); // --> instance gets created when the class is compile.

    private Calculator() {}

    public static Calculator getInstance() {
        return instance;
    }

}
Issue: The instance will always be created, we want it or not. What if the instance is expensive to create and no one uses it?

```

- A singleton provides a means to ensure that only one object instance of a class is created and referenced by clients accessing that class. Most often, singletons are defined for a particular process. However, means for defining singletons within a certain distributed processing domain can also be defined.

- Serialization, i.e., the process of storing the state of the class in the file system can also create multiple instances of the class.

- In Java, the most acceptable singleton implementation is through the use of `Enumerations` (as long as you need to extend from another class).

```

```

---
