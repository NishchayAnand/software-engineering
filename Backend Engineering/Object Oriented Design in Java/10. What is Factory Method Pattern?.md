
Even when we follow the **Dependency Inversion Principle** and inject dependencies into clients rather than instantiating them directly, the creation of those dependencies still happens somewhere. 

Developers can unknowingly create objects directly in ways that can lead to scattered dependencies across the codebase, making the system harder to maintain and evolve. Any change to the way an object is instantiated forces multiple updates across different parts of the system.

Moreover, **code that directly instantiates concrete classes is especially fragile** because it’s tightly coupled to specific implementations, which are likely to change as the system grows. This duplication of object creation logic not only violates the DRY principle but also increases the overall maintenance effort.

The **Factory Pattern** solves this by centralizing the object creation logic, promoting consistency, and making the system easier to extend or modify without widespread code changes.


---

even if we follow dependency inversion principle and pass dependencies to client rather instantiating it directly in the client, we would still be instantiated the dependency somewhere in the low-level components.

Embedding the object creation logic across the codebase leads to scattered dependencies and increased maintenance effort.

**Code that directly instantiates concrete classes is particularly prone to change** as the system evolves. 

Object creation code is duplicated across multiple parts of the application, leading to maintenance issues.

---
### What is a Factory?

In software design, a **factory** refers to anything responsible for creating objects. 

The main idea behind using a factory is to **encapsulate the creation logic** so that the client code (the part of the application using the objects) doesn't need to know the details of how those objects are instantiated.

The **Simple factory** pattern  describes a class that has one creation method with a large conditional that based on method parameters chooses which product class to instantiate and then return.


Since these classes often undergo modifications or extensions,

A simple factory is usually represented by a single method in a single class. Over time, this method might become too big, so you may decide to extract parts of the method to subclasses. Once you do it several times, you might discover that the whole thing turned into the classic factory method pattern.


even if we follow dependency inversion principle and pass dependencies to client rather instantiating it directly in the client, we would still be instantiated the dependency somewhere in the low-level components.






The **Factory Method Pattern** encapsulates object creation by letting subclasses decide what objects to create. All the responsibility of instantiation can be moved into a **method** that acts as a **factory**.

**A factory method isolates the client code in the superclass from knowing what kind of concrete product is actually created.**

Allows for more modular and extensible code. New object types can be added by creating new subclasses without modifying the main factory interface or client code.