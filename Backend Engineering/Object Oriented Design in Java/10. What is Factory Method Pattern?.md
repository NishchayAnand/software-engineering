
<span style="color:green;font-weight:bold;background:beige;">Developers can unknowingly create objects directly in ways that can lead to scattered dependencies across the codebase</span>, making the system harder to maintain and evolve. Any change to the way an object is instantiated forces multiple updates across different parts of the system.

Even when we follow the **Dependency Inversion Principle** and inject dependencies into clients rather than instantiating them directly, the creation of those dependencies still happens somewhere.

**Example**

```
interface DatabaseConnection {
    void connect();
}
```

```
class MySQLConnection implements DatabaseConnection {
    
    String host;
    int port;
    String username;
    String password;

    MySQLConnection(String host, int port, String username, String password) {
        this.host = host;
        this.port = port;
        this.username = username;
        this.password = password;
    }

	@Override
    void connect() {
        System.out.println("Connecting to MySQL at " + host + ":" + port);
    }
    
}
```

```
// client 1
class UserService {
    
    private DatabaseConnection connection;

    UserService(DatabaseConnection connection) {  // Dependency is injected here
        this.connection = connection;
    }

    void getUserDetails() {
        connection.connect();
        System.out.println("Fetching user details...");
    }
    
}
```

```
// client 2
class OrderService {
    
    private DatabaseConnection connection;

    OrderService(DatabaseConnection connection) {  // Dependency is injected here
        this.connection = connection;
    }

    void createOrder() {
        connection.connect();
        System.out.println("Creating order...");
    }
    
}
```

```
class Client {
    public static void main(String[] args) {
        
        DatabaseConnection connection = new MySQLConnection("localhost", 3306,                                                               "root", "admin123");

        UserService userService = new UserService(connection);
        userService.getUserDetails();

        OrderService orderService = new OrderService(connection);
        orderService.createOrder();
        
    }
}
```

<span style="color:green;font-weight:bold;background:beige;">When the</span> **`Client`** <span style="color:green;font-weight:bold;background:beige;">code directly instantiates the</span> **`MySQLConnection`** <span style="color:green;font-weight:bold;background:beige;">concrete class, it becomes tightly coupled to that specific implementation</span>. This makes the code fragile and harder to maintain because:

- If the constructor parameters of **`MySQLConnection`** change, the **`Client`** must also change.
- If you want to switch to a different database (like **`PostgreSQLConnection`**), you must modify the **`Client`** code.

---
### What is a Factory?

In software design, a **factory** refers to anything responsible for creating objects. 

The main idea behind using a factory is to **encapsulate the creation logic** so that the client code (the part of the application using the objects) doesn't need to know the details of how those objects are instantiated.

**Example**

```
class DatabaseConnectionFactory {

    public static DatabaseConnection getConnection(String type) {
        
        if (type.equalsIgnoreCase("mysql")) {
            return new MySQLConnection();
        } else if (type.equalsIgnoreCase("postgresql")) {
            return new PostgreSQLConnection();
        }
        
        throw new IllegalArgumentException("Unsupported database type");
        
    }
}
```

```
class Client {
    public static void main(String[] args) {

        DatabaseConnection connection = DatabaseConnectionFactory.                                                                        getConnection("mysql");

        OrderService orderService = new OrderService(connection);
        orderService.createOrder();
        
    }
}
```

In this design, the object creation logic is entirely handled by the **`DatabaseConnectionFactory`**, keeping the client free from any knowledge of how the connection is instantiated. 

This separation allows you to switch to a different database (like **`PostgreSQLConnection`**) without making any changes to the client code. As a result, the system becomes easier to maintain, extend, and test.

```
class Client {
    public static void main(String[] args) {

        // Switching to PostgreSQL — no client code change required!
        DatabaseConnection pgConnection = DatabaseConnectionFactory.                                                                 getConnection("postgresql");

        OrderService orderService = new OrderService(pgConnection);
        orderService.createOrder();
        
    }
}
```

> **NOTE:** In a real-world application, instead of hardcoding `"mysql"` or `"postgresql"` in your code, you would typically read this value from a **configuration file**. This allows you to switch between different database types by simply changing the configuration.

However, over time, the `getConnection()` method of `DatabaseConnectionFactory` might become too big, so you may decide to extract parts of the method to subclasses. Once you do it several times, you might discover that the whole thing turned into the classic factory method pattern.



---

make factory class abstract 

The **Simple factory** pattern  describes a class that has one creation method with a large conditional that based on method parameters chooses which product class to instantiate and then return.




The **Factory Pattern** solves this by centralizing the object creation logic, promoting consistency, and making the system easier to extend or modify without widespread code changes.


Since these classes often undergo modifications or extensions,

A simple factory is usually represented by a single method in a single class. Over time, this method might become too big, so you may decide to extract parts of the method to subclasses. Once you do it several times, you might discover that the whole thing turned into the classic factory method pattern.


even if we follow dependency inversion principle and pass dependencies to client rather instantiating it directly in the client, we would still be instantiated the dependency somewhere in the low-level components.






The **Factory Method Pattern** encapsulates object creation by letting subclasses decide what objects to create. All the responsibility of instantiation can be moved into a **method** that acts as a **factory**.

**A factory method isolates the client code in the superclass from knowing what kind of concrete product is actually created.**

Allows for more modular and extensible code. New object types can be added by creating new subclasses without modifying the main factory interface or client code.

> **NOTE:** As the simple factory grows and starts handling too many responsibilities, it naturally becomes a candidate for refactoring into the **Factory Method Pattern**. This evolution is a common and healthy part of scaling a software design.

--- 
### EXTRA

That’s why it’s better to inject a **`DatabaseConnection`** interface dependency created via a Factory.