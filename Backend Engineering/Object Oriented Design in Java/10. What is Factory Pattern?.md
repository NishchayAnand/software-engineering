
In software design, a **factory** refers to anything responsible for creating objects. 

The main idea behind using a factory is to **encapsulate the creation logic** so that the client code (the part of the application using the objects) doesn't need to know the details of how those objects are instantiated. 

---
### When to Apply Factory Pattern?

The Factory Pattern is useful when object creation involves complex logic, configuration, or dependencies that shouldn't be exposed to client code.

<span style="color:purple;font-weight:bold;">Bad Design</span>

```
class MySQLConnection {
    String host;
    int port;
    String username;
    String password;

    MySQLConnection(String host, int port, String username, String password) {
        this.host = host;
        this.port = port;
        this.username = username;
        this.password = password;
    }

    void connect() {
        System.out.println("Connecting to MySQL at " + host + ":" + port);
    }
}
```

```
class Client {
    public static void main(String[] args) {
        MySQLConnection connection = new MySQLConnection("localhost", 3306,                                                               "root", "admin123");
        connection.connect();
    }
}
```

This approach forces the **`Client`** to know all the connection details. Any change in connection settings requires updates across all clients. 

Also, directly instantiating a database connection inside the **`Client`** tightly couples the **`Client`** with the **`MySQLConnection`** class. This means any change in the connection logic or switching to a different database (e.g., `PostgreSQL`) would require modifying the **`Client`** code itself.

---
### How to Apply Factory Pattern?

The solution is to create a hierarchy of factory classes, defining a super type, usually an abstract class and then create **simple factory** class for each object type.

**Issue with Simple Factory:** Often relies on complex conditional statements to determine the type of object to create. As the number of object types increases, the factory method becomes cumbersome to maintain and less readable. Also, it violates the **Dependency Inversion Principle.**





---

- If the thing creating objects is a method, it's known as a **factory method**. 
- If the thing creating objects is also an object, it's known as an **abstract factory**. These are useful when you want to separate construction of objects into a completely separate Java interface.

---
### Rethinking Factory With Factory Method

The Factory Method Pattern encapsulates object creation by letting subclasses decide what objects to create. All the responsibility of instantiation can be moved into a **method** that acts as a **factory**.

**A factory method isolates the client code in the superclass from knowing what kind of concrete product is actually created.**

Allows for more modular and extensible code. New object types can be added by creating new subclasses without modifying the main factory interface or client code.


---
### Scaling Factory With Abstract Factory

**DEFINITION:** Provides an interface for creating families of related or dependent objects without specifying their concrete classes.

An abstract factory defines the interface that all concrete factories must implement, which consists of a set of methods for producing products. Each method in that interface is responsible for creating a concrete product, and we implement a subclass of the abstract factory to supply those implementations. So, abstract methods are a natural way to implement your product methods in your abstract factories.

An abstract factory provides an interface for a family of products. By writing code that uses this interface, we decouple our code from the actual factory that creates the products.

From abstract factory, we define one or more concrete factories that produce the same products, but with different implementations.

> NOTE: The interface needs to change if new products needs to be added.

---


You've already seen some examples of factory methods, such as `Stream.of()`. One of them is `Stream.of()`, which is a static factory method.Instead of exposing the stream constructor directly to clients, the designers of the stream API decided to hide the construction details behind a static factory method.

The Factory Method pattern suggests that you replace direct object construction calls (using the new operator) with calls to a special factory method.

> **NOTE:** The objects are still created via the new operator, but it’s being called from within the factory method. Objects returned by a factory method are often referred to as products.

You can override the factory method in a subclass and change the class of products being created by the method.

Promotes **loose coupling** — the code that uses the object doesn’t need to know about its concrete class.

Useful when the class of the object to be created might change in the future.

Follows the **Open/Closed Principle** — easy to introduce new types without modifying existing code.

---
If this creation logic is implemented as a **method** within a class, it's called a **Factory Method**. The **Factory Method Pattern** allows subclasses to override this method to determine which specific object to instantiate — making it useful when different classes in a hierarchy are responsible for creating different kinds of objects.

On the other hand, when the object creation responsibility is moved into a separate **factory object**, we call it an **Abstract Factory**. The **Abstract Factory Pattern** defines an interface for creating families of related objects without specifying their concrete classes. This pattern is ideal when your system needs to produce a variety of related objects (for example, UI components like buttons, checkboxes, and menus that must all follow a certain style or theme). With an abstract factory, you encapsulate these creation methods inside a factory class, providing a clear separation of concerns and promoting modular, maintainable code.

In short, **Factory Method** is a single method that subclasses can customize, while **Abstract Factory** is a complete factory object offering multiple factory methods to create related objects. Both patterns help manage object creation but are applied based on the scope and complexity of the creation logic you want to abstract.

---
For example, if creating an object involves setting multiple properties, handling dependencies, or choosing between several subclasses, a factory can manage all of this behind the scenes. 

The client simply calls the factory to get the object it needs, without worrying about the "how" of its creation. This not only promotes **loose coupling** but also adheres to the **Single Responsibility Principle**, as object creation logic is separated from business logic.

---
### EXTRA

Code that instantiates concrete classes is an area of frequent change. We know it's always better to encapsulate code that varies. Instantiation is an activity that shouldn't always be done in public and can often lead to coupling problems.

We aren't supposed to program to an implementation, but every time we use the **new** operator, we are certainly instantiating a concrete class which is definitely an implementation and not an interface.

If your code is written to an interface, then it will work with any new class implementing that interface (through polymorphism). However, when you have code that makes use of lots of concrete classes, the code may have to be changed as new concrete classes are added. To extend your code with new concrete types, you'll have to reopen it for modification, violating the **open-close principle.**

> **NOTE:** Factory Pattern promotes **Open-Close Principle** and **Dependency Inversion Principle**.



## Simple Factory Pattern




## Abstract Factory



## Advantages of Factory Pattern

By placing all the creation code in object or method, we can avoid duplication in our code and provide one place to perform maintenance. That also means **clients depend only upon interfaces rather than the concrete classes required to instantiate objects.** This allows us to program to an interface, not an implementation.

---

**Q. Difference between Simple Factory Pattern and Factory Method Pattern.**

In Simple Factory Pattern, the factory object is responsible for object creation.

In Factory Method Pattern, the factory method lets a class defer instantiation to subclasses. With factory method, the creator is not tightly coupled to any concrete product.

In simple words, the Simple Factory Pattern centralizes object creation in a single factory class, while the Factory Method Pattern decentralizes it by delegating object creation to subclasses, providing more flexibility and adherence to object-oriented design principles.

---

**Q. Difference between Factory Method Pattern and Abstract Factory Pattern.**

Both abstract factory and factory method create objects. But abstract factory does that through object composition and factory method does that through inheritance.

To create objects using Factory Method, you need extend a class and provide an implementation for a factory method.

---

It simply calls the factory to get the object it needs, without worrying about the **"how"** of its creation.



