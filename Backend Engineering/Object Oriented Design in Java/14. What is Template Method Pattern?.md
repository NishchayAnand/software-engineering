
A bad software design often contains code duplication, inconsistent workflows, and scattered logic, making the system harder to maintain, prone to bugs, and resistant to change.

**Example**

```
public class CreditCardPaymentProcessor {

	public void validatePaymentDetails() {
		System.out.println("Validating credit card...");
	}

    public void executePayment(double amount) {
	    System.out.println("Paid $" + amount + " using Credit Card");
    }

    public void sendReceipt() {
        System.out.println("Receipt sent to customer.");
    }
	
}
```

```
public class PayPalPaymentProcessor {

	public void validatePaymentDetails() {
		System.out.println("Validating PayPal...");
	}

    public void executePayment(double amount) {
	    System.out.println("Paid $" + amount + " using PayPal");
    }

    public void sendReceipt() {
        System.out.println("Receipt sent to customer.");
    }
	
}
```

```
public class Client {
    public static void main(String[] args) {
        CreditCardPaymentProcessor ccProcessor = new                                                                                CreditCardPaymentProcessor();
        ccProcessor.validatePaymentDetails();
        ccProcessor.executePayment(100);
        ccProcessor.sendReceipt();  // Correct flow

        PayPalPaymentProcessor ppProcessor = new PayPalPaymentProcessor();
        ppProcessor.executePayment(200);
        ppProcessor.sendReceipt();
        // Oops! Forgot to call validatePaymentDetails() for PayPal!
    }
}
``` 

Both `CreditCardPaymentProcessor` and `PayPalPaymentProcessor` repeat the same `sendReceipt()` method. This violates the **Don't Repeat Yourself (DRY)** principle 

Additionally, because the `Client` manages the sequence of operations, there’s no centralized enforcement of the correct payment processing workflow, which can easily result in errors if a step is missed or altered. 

---
### Good Design: Keep Common Logic in One Place

Placing shared logic in a single location allows you to ensure that any change affects all dependent code, making maintenance easier, reducing bugs, and keeping the system consistent.

The **Template Method Pattern** suggests that you move the **common steps** into an **abstract base class** and define a **template method** that enforces the sequence of steps.

The intent of a **template method** is to implement an algorithm, leaving the definition of some operations or steps to a concrete subclass. Each subclass must provide its own implementation for the undefined steps, ensuring that while the overall process remains consistent, specific behaviors can vary as needed.

> **NOTE:** The **Template Method Pattern** hides away all boilerplate code and allows the developer to concentrate solely on business logic.

---
### How to Apply Template Method Pattern?

The Template Method pattern suggests that you break down an algorithm into a series of steps, turn these steps into methods, and put a series of calls to these methods inside a single template method.

The steps may either be `abstract`, or have some default implementation. To use the algorithm, the client is supposed to provide its own subclass, implement all abstract steps, and override some of the optional ones if needed (but not the template method itself).

The template method is usually declared `final` to prevent subclasses from reworking the sequence of steps in the algorithm.

> NOTE: This pattern shows up so often because it's a great design tool for creating frameworks, where the framework controls how something gets done, but leaves you (the person using the framework) to specify your own details about what is actually happening at each step of the framework's algorithm.

---
### Limitations of Template Method Pattern

**Template Method tends to make client code tightly coupled to concrete subclasses**  
because the client must know which subclass to instantiate.



---
### Extra


The Template Method pattern suggests that you <span style="color:green;font-weight:bold;background:beige;">break down an algorithm into a series of steps, turn these steps into methods, and put a series of calls to these methods inside a single template method</span>.

This **template method** acts like a skeleton for an algorithm, where each step can be represented by a method. Some methods will be handled by the class holding the template method whereas others will be left for the subclasses to handle. The methods that need to be supplied by subclass are declared abstract.

Methods have body that specify a sequence of statements or steps. You can think of methods as templates that outline a series of instructions to execute. However, in some cases, you may not know how to implement some steps where you may want to define a generic template, leaving some steps as abstract methods so other classes than supply an implementation.

The base class **dictates the workflow**, and subclasses provide details.

NOTE: The template method pattern is an alternative to the strategy pattern. The intention of both is similar, but uses inheritance and other composition.

**DEFINITION: Defines the skeleton of an algorithm in a method, deferring some steps to subclasses. Template method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure.**



When we've got code duplication, that's a good sign we need to clean up the design.

One or more steps are defined to be abstract and implemented by a subclass. This ensures the algorithm's structure stays unchanged, while subclasses provide some part of the implementation.



A hook is a method that is declared in the abstract class, but only given an empty or default implementation. This gives subclasses the ability to **"hook into"** the algorithm, if they wish (a subclass is free to ignore the hook).

> **NOTE:** Use hooks when part of the algorithm is optional. With hooks, a subclass may choose to implement that hook, but it doesn't have to.

It's a good thing to keep the number of abtract methods small in your template method. Sometimes you can do this by not making the steps of your algorithm too ganular. But it's obviously a tradeoff: **the less granularity, the less flexibility**.

## Real World Example



Servlets are based on template method pattern. `Sort()` method of Java `Arrays` class is based on Template Method Pattern.

**The `sort()` template method in Arrays gives us the algorithm, but you need to tell it how to compare ducks, which you do by implementing the `compareTo()` method.**

> NOTE: The primitive sort operation, for e.g. merge sort uses compareTo method to compare two objects.

- `Sort() -> mergeSort() -> ((Comparable)obj1).compareTo((Comparable)obj2) -> type of obj1 and obj2 must implement the Comparable interface.`

## EXTRA

- Encapsulate Algorithms

- It defines the steps of an algorithm, allowing subclasses to provide the implementation for one or more steps.

- 

- 

- NOTE: It's a good idea to minimise the number of abstract methods by not making the steps too granular, but it's obviously a tradeoff. The less granularity, the less flexibility.

- Abstract methods can be replaced with hook. Hooks are optional. Abtract class may provide a default implementation.

- 

- The template method pattern uses inheritance to change part of an algorithm and the strategy pattern uses composition uses composition to change the entire algorithm.

