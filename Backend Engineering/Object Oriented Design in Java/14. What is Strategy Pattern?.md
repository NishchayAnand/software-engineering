
When you mix **changing behavior** and **stable behavior** inside the same class, that class becomes rigid and harder to maintain.

**Example: Payment Gateway**

```
public class PaymentGateway {
    public void processPayment(String paymentMethod, double amount) {
        if (paymentMethod.equals("creditcard")) {
            System.out.println("Processing " + amount + " using Credit Card");
        } else if (paymentMethod.equals("paypal")) {
            System.out.println("Processing " + amount + " using PayPal");
        } else if (paymentMethod.equals("upi")) {
            System.out.println("Processing " + amount + " using UPI");
        } else {
            throw new IllegalArgumentException("Unsupported payment type");
        }
    }
}
```

In the `PaymentGateway` class, the logic for **how payments are processed (changing behavior)** can evolve over time. However, general action of **processing a payment (stable behavior)** remains the same.

By mixing these concerns, the `PaymentGateway` class is violating two fundamental software design principles:

- **Single Responsibility Principle (SRP)**: It takes on multiple responsibilities within the same class. First, it is responsible for **processing the payment**, which should be its primary task. Second, it handles the logic for **deciding which payment method to use** by checking the type of payment within conditional statements. Third, it directly contains the **execution logic for each payment method**, embedding the specific steps required to perform each type of payment.

- **Open-Closed Principle (OCP)**: Every time a new payment method is introduced, you must modify the existing class, which increases the risk of breaking existing functionality.

> **NOTE:** Identify **stable behavior** as _`what always happens`_ in your business process, and **changing behavior** as _`how it happens`_ that may differ or grow over time.

---
### Good Design: Separate Changing Behavior from Stable Behavior

Tight coupling of responsibilities makes the class fragile, harder to extend, and prone to errors, highlighting the need to separate changing behavior (payment logic) from stable behavior (payment processing workflow).


The Strategy Pattern 

move out the execution logic of each payment method.

move out the deciding logic of which payment method to use.

---
### How to Apply Strategy Pattern?

By applying the **Strategy Pattern**, you separate these concerns:

- The `PaymentProcessor` handles only the stable behavior (delegating the processing).
    
- The `PaymentStrategy` implementations handle the varying payment logic.

	The **Strategy Pattern** corrects this by keeping the stable part in the context class and encapsulating the changing parts in interchangeable strategies,


---



### Separate Behavior Using Inheritance

payment method are strategies

You can use inheritance to separate changing behavior from stable behavior by creating a base class with common logic and extending it with subclasses that override only the parts that differ. 

**Example: Payment Processor**

```
interface PaymentProcessor {
    void processPayment(double amount);
}
```

```
public class CreditCardPaymentProcessor implements PaymentProcessor {
    @Override
    public void processPayment(double amount) {
        System.out.println("Paid " + amount + " using Credit Card");
    }
}

public class PayPalPaymentProcessor implements PaymentProcessor {
    @Override
    public void processPayment(double amount) {
        System.out.println("Paid " + amount + " using PayPal");
    }
}
```

```
public class Client {
	public static void main(String[] args) {
		PaymentProcessor processor = new CreditCardPaymentProcessor();
		processor.processPayment(500);

		// Switch to PayPal
		processor = new PayPalPaymentProcessor;
		processor.processPayment(250);
	}
}
```

Inheritance allows you to move the **execution logic for each payment method** into subclasses. This way you can make `PaymentProcessor` follow **Open-Close Principle**.


The **decision for which payment method to use is now handled through inheritance. 

You can’t change the behavior at runtime easily (you’re stuck with what you extend).


---


— the system always needs to "process a payment."


If you mix both changing and stable behaviors inside the same class, the class becomes rigid. 

For example, in the `PaymentProcessor` class,  can vary or evolve over time. However, the  remains consistent no matter what.


---

Think of strategies as behaviours. Encapsulate behaviour in a object to delegate functionality.

The idea of the Strategy Pattern is for a given interface to assign different variants of an algorithm to different implementations with the choice of which to choose being made at runtime.

Remember as "From Inheritance to Composition with Strategy Pattern".

Based on Design Pattern: "We should ."

---

**DEFINITION: Strategy Pattern defines a family of algorithms and encapsulatess each one and makes them interchangeable.**



- The DAO pattern is a special case of the Strategy design pattern (GoF), in which a specific implementation "strategy" is refactored into an interface to allow it to be changed independently of the coarser-grained object. The Strategy pattern plays a big part in well-designed OO applications, so there's much value in making it as easy as possible to use.

- JNDI Lookup is also based on the Strategy Design Pattern.

- Strategy patterns encapsulate interchangeable underlying algorithms and provide the same interface for accessing such algorithms. A strategy pattern is similar to an adapter pattern, but it is mainly used to provide pluggable policies and algorithmic processing modules in a design.

- "I encapsulated this behavior in an interface, implementing each variation in a class that I will inject in this other class to delegate the behavior".

- 

- Subclass Explosion: It happens when the number of classes needed to have a new functionality to a given class hierarchy grows exponentially.

- Strategy Pattern states that "Define a family of algorithms, encapsulates each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.

- In simple words, it allows you to change a part of a system independently of all other parts.

- 

- Creates a design that encapsulates a family of behaviors into their own set of classes and lets you changes them as runtime.

- It isn't just polymorphism: It uses polymorphism to make behaviors interchaneable, but it can be thought as a mix of the following design principles:
  - Encapsulating what changes
  - Favoring composition over Inheritance
  - Open-Close Principle
  - Programming to interfaces
