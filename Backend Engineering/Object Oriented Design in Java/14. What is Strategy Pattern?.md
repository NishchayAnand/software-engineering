
When a class hardcodes a specific algorithm or logic, the class becomes **rigid** and **difficult to extend**. You cannot easily swap or change the algorithm without modifying the class itself.

**Example**

```
public class PaymentProcessor {
    public void processPayment(String type, double amount) {
        if (type.equals("creditcard")) {
            System.out.println("Paid " + amount + " using Credit Card");
        } else if (type.equals("paypal")) {
            System.out.println("Paid " + amount + " using PayPal");
        } else if (type.equals("upi")) {
            System.out.println("Paid " + amount + " using UPI");
        } else {
            throw new IllegalArgumentException("Unsupported payment type");
        }
    }
}
```

The `PaymentProcessor` is directly responsible for knowing every type of payment. Every time a new payment type is added, we have to modify this class, thereby violating the **Open-Closed Principle**. 

---



---

Think of strategies as behaviours. Encapsulate behaviour in a object to delegate functionality.

The idea of the Strategy Pattern is for a given interface to assign different variants of an algorithm to different implementations with the choice of which to choose being made at runtime.

Remember as "From Inheritance to Composition with Strategy Pattern".

Based on Design Pattern: "We should separate the behavior that changes from the behavior that stays same."

---

**DEFINITION: Strategy Pattern defines a family of algorithms and encapsulatess each one and makes them interchangeable.**



- The DAO pattern is a special case of the Strategy design pattern (GoF), in which a specific implementation "strategy" is refactored into an interface to allow it to be changed independently of the coarser-grained object. The Strategy pattern plays a big part in well-designed OO applications, so there's much value in making it as easy as possible to use.

- JNDI Lookup is also based on the Strategy Design Pattern.

- Strategy patterns encapsulate interchangeable underlying algorithms and provide the same interface for accessing such algorithms. A strategy pattern is similar to an adapter pattern, but it is mainly used to provide pluggable policies and algorithmic processing modules in a design.

- "I encapsulated this behavior in an interface, implementing each variation in a class that I will inject in this other class to delegate the behavior".

- 

- Subclass Explosion: It happens when the number of classes needed to have a new functionality to a given class hierarchy grows exponentially.

- Strategy Pattern states that "Define a family of algorithms, encapsulates each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.

- In simple words, it allows you to change a part of a system independently of all other parts.

- 

- Creates a design that encapsulates a family of behaviors into their own set of classes and lets you changes them as runtime.

- It isn't just polymorphism: It uses polymorphism to make behaviors interchaneable, but it can be thought as a mix of the following design principles:
  - Encapsulating what changes
  - Favoring composition over Inheritance
  - Open-Close Principle
  - Programming to interfaces
