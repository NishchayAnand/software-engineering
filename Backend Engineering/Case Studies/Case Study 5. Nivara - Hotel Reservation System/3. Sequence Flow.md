
Let’s understand the **step-by-step sequence flow of each of the core use cases** to gain deeper insights into how the system works in practice.

![sequence-flow](sequence-flow-hrs.png)

<span style="color:red;">(design choices here are more focused on low level design principles and patterns)</span>

---
### Use Case 1: Search Hotels

A straightforward approach would be to let a single `SearchService` own all data required for hotel search. However, a search query inherently requires combining **two fundamentally different categories of data**. 

- On one side, it relies on relatively static information such as hotel names, locations, images, amenities, policies, and room-type definitions, that changes infrequently and can be aggressively cached. 

- On the other side, it depends on highly dynamic data like room availability and pricing, which can change frequently due to bookings, demand fluctuations, or pricing rules.

Treating both data types uniformly forces the system to optimize for the most volatile data, which increases latency, reduces cache effectiveness, and wastes compute resources. To avoid this, the system can be decomposed into specialized services. 

- A dedicated `HotelService` can manage stable hotel profile content and be optimized for read-heavy access and aggressive caching. 

- An `InventoryService` can handle fast-changing room availability with a focus on freshness and concurrency control, while a `PricingService` can manage dynamic pricing logic and frequent updates.

- The `SearchService` can then act as an **orchestrator**, coordinating calls to these backend services, retrieving static and dynamic data in parallel, and aggregating the results into a unified search response.

The following interactions describe the step-by-step flow between the **user interface** and the **backend components** during this operation:

1. The `Customer` enters the search criteria such as `location`, `check_in_date`,  `check_out_date` and submits the **Search Hotels** form.

2. The `Frontend` sends a `GET /hotels/hotel-listings` request to the `SearchService`, including all the selected form parameters: `location`, `check_in_date` and `check_out_date`.

3. The `SearchService` coordinates with downstream services to determine hotel availability and pricing.  

	- **Hotel Lookup**: Sends a GET request to the `HotelService` to fetch all hotels listed for the selected `location`.  

	- **Availability Check**: For the list of hotels returned, it queries the `InventoryService` to identify hotels with at least one available room for the specified `check_in_date` and `check_out_date`.

	- **Pricing Calculation**: For hotels with availability, it calls the `PricingService` to retrieve the `avgPerNightPrice` for the selected date range.

4. After aggregating hotel metadata, availability, and pricing information, the `SearchService` caches the final response (short TTL) and returns a list of available hotels to the `Frontend`.

5. The `Frontend` renders the response as a grid of `Hotel` cards, displaying key details such as: `hotelName`, `avgPricePerNight`, `availability`, `rating`, etc.

<span style="color:green;font-weight:bold;">Sequence Diagram</span>

```mermaid
sequenceDiagram
    actor Customer
    participant Frontend
    participant SearchService
    participant HotelService
    participant InventoryService
    participant PricingService

    Customer ->> +Frontend: Enter location, check-in-date, check-out-date
    Frontend ->> +SearchService: GET /hotels/hotel-listings

    SearchService ->> +HotelService: GET /hotels?location
    HotelService -->> -SearchService: List of hotels (metadata)

    SearchService ->> +InventoryService: POST /availability (hotelIds, dates)
    InventoryService -->> -SearchService: Available hotelIds

    SearchService ->> +PricingService: POST /pricing (hotelIds, dates)
    PricingService -->> -SearchService: avgPerNightPrice per hotel

    Note over SearchService: Store aggregated response (short TTL)
    SearchService -->> -Frontend: List of available hotels + pricing
    Frontend -->> -Customer: Render search results
```

---
### Use Case 2: View Hotel Details

Enable customers to view complete information about a selected hotel, including its **amenities**, **images**, **policies**, and the **availability of room types for the specified dates**.

The following interactions describe the step-by-step flow between the **user interface** and the **backend components** during this operation:

1. The `Customer` clicks on a `Hotel` thumbnail (e.g., `hotel_id = 101`).

2. The `Frontend` sends a `GET /hotels/{hotel_id}` request to the `HotelService` to fetch complete static information about that specific hotel. This includes high-resolution `images`, `amenities`, `descriptions`, `policies` etc. 

3. In parallel, a `GET /availability?hotel_id=101&check_in&check_out&guests` request is sent to the `InventoryService` to fetch up-to-date availability and pricing for each `RoomType`.

4. Finally, the `Frontend` merges the static hotel details from the `HotelService` with the dynamic room availability from the `InventoryService`, forming a complete hotel detail view. 

<span style="color:green;font-weight:bold;">Sequence Flow</span>

```mermaid
sequenceDiagram
	participant C as Customer
	participant UI as Frontend
	participant HS as HotelService
	participant IS as InventoryService

	%% Step 1: Customer clicks on hotel thumbnail
    C->>+UI: Click Hotel Thumbnail (hotel_id=101)

    %% Step 2: Frontend requests static hotel details
	UI->>+HS: GET /hotels/{hotel_id}
	HS-->>-UI: Static Hotel Details<br/>(images, amenities, policies)

    %% Step 3: Frontend requests dynamic availability
    UI->>+IS: GET /availability?hotel_id=101&check_in&check_out&guests
    IS-->>-UI: Availability & Pricing<br/>(per RoomType)

    %% Step 4: Merge results
    Note over UI: Merge static hotel details <br/>with dynamic availability

    %% Step 5: Show customer
    UI-->>-C: Display Complete Hotel Details Page
```

---
### Use Case 3: Make a Reservation

Enable customers to select a hotel and room type, provide guest details, make payment, and confirm a booking.

The following interactions describe the step-by-step flow between the **user interface** and the **backend components** during this operation:

1. The `Customer` selects one or more desired `RoomTypes` and specifies the `quantity` for each, along with the intended `check_in_date` and `check_out_date`. Once the selection is complete, the `Customer` clicks the “Book Now” button to proceed with the booking.

2. The `Frontend` sends a `POST \bookings` request to the `ReservationService`, including all reservation parameters and the `pricing_snapshot` to <span style="color:green;font-weight:bold;background:beige;">verify price consistency at checkout</span>.

<span style="color:red;">(will make an idempotency check - add this here)</span>

3. The `ReservationService` calls the `InventoryService` to place a temporary lock on the requested rooms. <span style="color:green;font-weight:bold;background:beige;">This prevents other customers from booking the same rooms while the current booking is in progress</span>. 

	- If the lock is successful, the `ReservationService` calls the `PricingService` to validate the final booking price. <span style="color:green;font-weight:bold;background:beige;">This ensures that the customer is charged the most up-to-date amount and avoids discrepancies with the earlier displayed pricing.</span>

	- If the rooms are not available, the `ReservationService` returns an error to the `Frontend`, prompting the `Customer` to revise their selection.

4. Once the pricing is confirmed, the `ReservationService` initiates the payment process by sending a request to the `PaymentService`, which in turn communicates with an external `Payment Gateway` such as a `Bank`, `CardProcessor`, or `UPIService`.

	- If the payment succeeds, the `ReservationService` finalizes the booking by persisting the `Reservation`, updating the `InventoryService` to permanently reduce room availability and triggering the `NotificationService` to send a booking confirmation to the customer via email, SMS, or push notification.

	- If the payment fails, the `ReservationService` releases the locked rooms in `InventoryService` and notifies the `Frontend` so the `Customer` can attempt payment again or choose another method.

5. Finally, the `Frontend` displays a "Booking Confirmation" page to the `Customer` containing the reservation details along with a unique `booking_reference_id`.

<span style="color:green;font-weight:bold">Sequence Diagram</span>

```mermaid
sequenceDiagram
    participant C as Customer
    participant UI as Frontend
    participant RS as ReservationService
    participant IS as InventoryService
    participant PS as PricingService
    participant Pay as PaymentService
    participant NS as NotificationService
    
    %% Interaction 1: Customer -> Frontend
    C->>+UI: Click "Book Now" Button
    Note right of C: 1. Select RoomTypes + Quantities <br/> 2. Set Check-In and Check-Out Dates
    
    %% Interaction 2: Frontend -> ReservationService
    UI->>+RS: POST /bookings
    
    %% Interaction 3: ReservationService -> InventoryService
    RS->>+IS: Place Temporary Lock (per room type & quantity)
    IS-->>-RS: message: Lock Acquired | Lock Not Acquired
    
    alt Lock Acquired
	    %% Interaction 3: ReservationService -> PricingService
	    RS->>+PS: Validate Final Price
	    PS-->-RS: message: Price Not Changed | Price Changed
	    
	    alt Price Not Changed
		    %% Interaction 4: ReservationService -> PaymentService
		    RS->>+Pay: Process Payment
		    Pay-->-RS: message: Payment Success | Payment Failure
		    
		    alt Payment Success
			    %% Interaction 5: ReservationService -> InventoryService
			    RS->>+IS: Update Inventory
			    IS-->-RS: message: Inventory Updated and Lock Released
			    %% Interaction 6: ReservationService -> NotificationService
			    RS->>+NS: Send Booking Confirmation
			    NS-->>-RS: message: Confirmation Sent
			    RS-->UI: HTTP ? with message: Booking Confirmed
			    UI-->C: Show message: Booking Confirmed & Unique Booking ID
			else Payment Failure
				RS->>+IS: Release Lock
				IS-->-RS: Lock Released
				RS-->>UI: HTTP ? with message: Payment Failed
				UI-->>C: Show message: Payment Failed, Try Again
			end
			
		else Price Changed
			RS-->>UI: HTTP ? with message: Price Changed
			UI-->>C: Show message: Price Updated, Accept Updated Price
		end
    
    else Lock Not Acquired
	    RS-->-UI: HTTP ? with message: Rooms Unavailable (adjust selections)
	    UI-->-C: Show message: Modify Room Types / Quantities
	end
```

> **Design Choice: Keep `PricingService` separate from `InventoryService`**
> 
> The `InventoryService` should focus only on availability while the `PricingService` should handle all price-related logic such as base rates, taxes, discounts and dynamic pricing. 
> 
> Separating them ensures clear responsibilities, accurate price re-verification at checkout, and flexibility to support promotions, personalization, and advanced yield models without complicating inventory code.

<span style="color:red">(extra - include this in above explanation)</span>

The booking process is designed as a two-step flow to ensure availability and payment integrity:

1. Book Now (Initiation)
    - When the user clicks Book Now, the system creates a reservation record in PENDING status.
    - A temporary inventory hold is placed to prevent the same room from being booked by another user.
    - The API responds with a reservationId and a payment session/redirect URL, which the client uses to proceed to payment.
    
2. Pay Now (Finalization)
    
    - When the user clicks Pay Now (or when the payment gateway callback occurs), the system verifies that the inventory hold is still valid.
    - It then processes the payment request with the payment provider.
    - If successful, the temporary hold is converted into a confirmed allocation, the reservation status is updated to CONFIRMED, and payment details are persisted.
    - Notifications are triggered (e.g., email/SMS).
    - If payment fails or the hold has expired, the system releases the hold and marks the reservation as FAILED or EXPIRED.

---

<span style="color:purple;font-weight:bold;">Advantages of separating</span> **room_types (hotelDB)** <span style="color:purple;font-weight:bold;">and</span> **room_inventory (inventoryDB)**

1. **Clear service ownership / bounded context**: Each service (HotelService vs InventoryService) owns its data model and lifecycle; teams can work independently.

2. **Independent scaling and resource tuning**: <span style="color:red;font-weight:bold;">Inventory workloads (frequent writes/updates, time-series queries) can be tuned differently (IO, partitioning, retention)</span> from hotel metadata (reads, joins).

3. **Optimized storage & indexing per workload**: <span style="color:red;font-weight:bold;">Inventory can be optimized for date-range queries, partitioned by month, use different indexes or even a time-series DB; room_types stays normalized for catalog queries.</span>

4. **Reduced contention and better performance:** <span style="color:red;font-weight:bold;">High-rate inventory updates won’t lock or bloat hotel metadata tables; write-heavy inventory does not impact reads on hotel data.</span>

5. **Flexible technology choice:** <span style="color:red;font-weight:bold;">Use the best DB per need (Postgres for room_types, a time-series DB or scaled Postgres for inventory) without forcing one model on both.</span>

6. **Security and compliance separation**: Different access control, retention, or audit policies per domain (inventory may have different SLA/retention requirements).

<span style="color:purple;font-weight:bold;">Short trade-offs to be aware of:</span>

1. **No cross-DB foreign keys**: you must use stable identifiers (UUIDs) or denormalize/replicate minimal metadata.

2. **Increased operational complexity:** cross-service calls, sync/consistency, monitoring, and distributed transactions (usually avoided).

3. **Potential eventual consistency**: <span style="color:red;font-weight:bold;">need strategies: synchronous lookups, denormalized copies, or event-driven replication.</span>

---
### Booking Workflow

**Option 1:**

When user clicks `Book Now` button, a request is sent to the inventory service to create a hold with `status = CREATED` and `expiry_date = NULL` for the request and update the inventory for the selected room types (using pessimistic locking). 

- If all inventory updates succeed, update the `status = CONFIRMED` and `expiry_at = DATETIME` attributes of the created hold.

- If anything fails, all updates to the database are reverted, including the created hold.

**Idempotency Check:** In case the user clicks the `Book Now` button multiple times, the hold will ensure that no inventory updates take place if a hold is active.

If the hold has expired when the user clicks the `Pay Now` button, the payment workflow will check the hold expiry and return stating `Inventory hold expired`.

If the hold expired while the payment was in-progress:
- If the payment completes, mark the hold as confirmed.
- If the payment fails, mark the hold as cancelled and revert the inventory updates. 

---
### What happens right after Razorpay says “payment successful”?

From Razorpay / frontend you basically get:

- `razorpay_payment_id`
- `razorpay_order_id`
- `razorpay_signature`
- plus your own context: `reservationId`, `holdId`, `amount`, etc.

Now someone has to:

1. **Verify the payment** (signature, amount, status) with Razorpay.
2. **Persist the payment record** (SUCCESS / FAILED etc.).
3. **Trigger domain changes**:
    
    - finalize reservation;
    - convert / confirm inventory hold;
    - maybe send emails, invoices, loyalty points, etc.

4. Handle **weird cases**:
    
    - payment is captured but reservation confirm fails;
    - duplicate callbacks / retries;
    - refunds / partial captures later.

<span style="color:red;font-weight:bold;">All of these are deeply _payment-centric_ concerns. That’s why the payment service should drive this, not reservation.</span>

---
### Why transactions matter SO much in payment flows

**Prevent** **partial state corruption**

Imagine this horrible scenario without a transaction:

1. You verify Razorpay signature → update Payment status to `SUCCESS_CLIENT_CALLBACK`.
2. **Before** you orchestrate hold/reservation calls…
3. DB update is saved.
4. Then the method throws an exception (network issue, service down, etc.).
5. Payment record is stuck halfway:
    - It says “signature validated”
    - But reservation is not finalized
    - Hold is not consumed
    - Payment is neither `SUCCESS` nor fully `FAILED`

This is a **corrupted state** → impossible to reliably recover from.

`@Transactional` prevents this by:

- NOT committing anything until the whole method returns successfully.

**Important subtle point:** `@Transactional` does **NOT** make downstream REST calls transactional.

Those happen outside DB boundaries. But it **DOES** protect your internal state. This is how sagas are normally written:

- Local DB changes → transactional (atomic)
- External service calls → outside transaction
- If an external call fails → you handle compensation (update DB state to reflect partial failure)

Without `@Transactional`, your saga breaks.

**Example**:

Inside your method you do:

```
payment.setStatus(SUCCESS_CLIENT_CALLBACK);
paymentRepository.save(payment);

inventoryClient.consumeHold(...); // external call
reservationClient.confirmReservation(...); // external call

payment.setStatus(SUCCESS);
paymentRepository.save(payment);
```

With `@Transactional`:

- If anything fails before the method completes → **no change** is saved
- If all steps succeed → both updates are committed together

Without it:

- You could save `SUCCESS_CLIENT_CALLBACK`
- Then hit an exception
- Leaving payment stuck forever in an incomplete state

This is how bookings get into “limbo” and cost people money.

---







