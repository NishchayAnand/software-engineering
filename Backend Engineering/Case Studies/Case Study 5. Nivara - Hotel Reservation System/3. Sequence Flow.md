
Let’s understand the **step-by-step sequence flow of each of the core use cases** to gain deeper insights into how the system works in practice.

![sequence-flow](sequence-flow-hrs.png)

<span style="color:red;">(design choices here are more focused on low level design principles and patterns)</span>

---
### Use Case 1: Search Hotels

A straightforward approach would be to let a single `SearchService` own all data required for hotel search. However, a search query inherently requires combining **two fundamentally different categories of data**. 

- On one side, it relies on relatively static information such as hotel names, locations, images, amenities, policies, and room-type definitions, that changes infrequently and can be aggressively cached. 

- On the other side, it depends on highly dynamic data like room availability and pricing, which can change frequently due to bookings, demand fluctuations, or pricing rules.

Treating both data types uniformly forces the system to optimize for the most volatile data, which increases latency, reduces cache effectiveness, and wastes compute resources. To avoid this, the system can be decomposed into specialized services. 

- A dedicated `HotelService` can manage stable hotel profile content and be optimized for read-heavy access and aggressive caching. 

- An `InventoryService` can handle fast-changing room availability with a focus on freshness and concurrency control, while a `PricingService` can manage dynamic pricing logic and frequent updates.

- The `SearchService` can then act as an **orchestrator**, coordinating calls to these backend services, retrieving static and dynamic data in parallel, and aggregating the results into a unified search response.

The following interactions describe the step-by-step flow between the **user interface** and the **backend components** during this operation:

1. The `Customer` enters the search criteria such as `location`, `checkInDate`,  `checkOutDate` and submits the **Search Hotels** form.

2. The `Frontend` sends a `GET /hotels/hotel-listings` request to the `SearchService`, including all the selected form parameters: `location`, `checkInDate` and `checkOutDate`.

3. The `SearchService` coordinates with downstream services to determine hotel availability and pricing.  

	- **Hotel Lookup**: Sends a GET request to the `HotelService` to fetch all hotels listed for the selected `location`.  

	- **Availability Check**: For the list of hotels returned, it queries the `InventoryService` to identify hotels with at least one available room for the specified `checkInDate` and `checkOutDate`.

	- **Pricing Calculation**: For hotels with availability, it calls the `PricingService` to retrieve the `avgPerNightPrice` for the selected date range.

4. After aggregating hotel metadata, availability, and pricing information, the `SearchService` caches the final response (short TTL) and returns a list of available hotels to the `Frontend`.

5. The `Frontend` renders the response as a grid of `Hotel` cards, displaying key details such as: `hotelName`, `avgPricePerNight`, `availability`, `rating`, etc.

<span style="color:green;font-weight:bold;">Sequence Diagram</span>

```mermaid
sequenceDiagram
    actor Customer
    participant Frontend
    participant SearchService
    participant HotelService
    participant InventoryService
    participant PricingService
    participant Cache

    Customer ->> +Frontend: Enter location, check-in-date, check-out-date
    Frontend ->> +SearchService: GET /hotels/hotel-listings

    SearchService ->> +HotelService: GET /hotels?location
    HotelService -->> -SearchService: List of hotels (metadata)

    SearchService ->> +InventoryService: POST /availability (hotelIds, dates)
    InventoryService -->> -SearchService: Available hotelIds

    SearchService ->> +PricingService: POST /pricing (hotelIds, dates)
    PricingService -->> -SearchService: avgPerNightPrice per hotel

    SearchService ->> Cache: Store aggregated response (short TTL)
    SearchService -->> -Frontend: List of available hotels + pricing
    Frontend -->> -Customer: Render search results
```


This design allows each service to scale independently, minimizes performance interference, and ensures fast search responses without compromising the accuracy required for downstream booking flows.

---
### Use Case 2: View Hotel Details

The **View Hotel Details** use case differs from **Search Hotels** in both **scope and load characteristics**. While hotel search is optimized for high-volume traffic and aggregated results across many hotels, viewing hotel details is a **low-volume, deep read** focused on a single hotel. This interaction typically involves richer data such as detailed descriptions, images, amenities, policies, and room-level information.

Unlike the Search Hotels flow, where the `SearchService` acts as an orchestrator, the **frontend can directly coordinate** with the `HotelService`, `InventoryService`, and `PricingService` to render the hotel details page.

The following interactions describe the step-by-step flow between the **user interface** and the **backend components** during this operation:

1. The `Customer` selects a hotel from the search results on the user interface.

2. The `Frontend` issues **three asynchronous requests** in parallel:

	- Sends a `GET /hotels/{hotelId}` request to the `HotelService` to retrieve static hotel information such as the hotel name, descriptions, amenities, and policies (typically served from cache, with database fallback).

	- Sends a `POST /availability` request to the `InventoryService` to retrieve room-level availability for the selected date range.

	- Sends a `POST /pricing` request to the `PricingService` to calculate and fetch pricing details for each available room type.

3. The `Frontend` aggregates responses from the `HotelService`, `InventoryService`, and `PricingService`, and renders the **Hotel Details Page**, displaying hotel profile information along with available room types and their corresponding prices.

<span style="color:green;font-weight:bold;">Sequence Flow</span>

```mermaid
sequenceDiagram
    actor Customer
    participant Frontend
    participant HotelService
    participant InventoryService
    participant PricingService
    participant Cache

    Customer ->> +Frontend: Select hotel from search results

    par Fetch hotel metadata
        Frontend ->> +HotelService: GET /hotels/{hotelId}
        alt Cache hit
            Cache -->> HotelService: Hotel profile data
        else Cache miss
            HotelService ->> Cache: Store hotel profile (long TTL)
        end
        HotelService -->> -Frontend: Hotel metadata
    and Check availability
        Frontend ->> +InventoryService: POST /availability (hotelId, dates)
        InventoryService -->> -Frontend: Room-level availability
    and Fetch pricing
        Frontend ->> +PricingService: POST /pricing (hotelId, dates)
        PricingService -->> -Frontend: Pricing per room type
    end

    Note over Frontend: Aggregate responses
    Frontend -->> -Customer: Render Hotel Details Page
```


This approach avoids unnecessary backend orchestration, reduces end-to-end latency, and simplifies the request flow, while still preserving clean service boundaries and strict data ownership. Each service remains responsible for its own domain, and the frontend aggregates the responses to present a complete and accurate view to the user.

**When Frontend Aggregation Is a Good Approach (only for reference)**

This pattern is well-suited when the use case has **moderate or low request volume**, such as **View Hotel Details**. Each user action typically results in one page load, not repeated or bursty traffic like search. The frontend making a few additional calls does not create scaling issues.

The frontend aggregation works well when orchestration is limited to:

- Calling services in parallel
- Passing user-selected parameters
- Merging responses for display  
- There is no complex decision-making, workflow state, or transactional logic involved.

Frontend aggregation is appropriate when:

- Data can be slightly inconsistent (eventual consistency is acceptable)
- There is no need for atomic guarantees across services  
    For example, viewing availability and pricing does not require the same guarantees as booking.

---
### Use Case 3: Make Reservations

Enable customers to select a hotel and room type, provide guest details, make payment, and confirm a booking.

The following interactions describe the step-by-step flow between the **user interface** and the **backend components** during this operation:

1. The `Customer` selects one or more desired `RoomTypes` and specifies the `quantity` for each, along with the intended `check_in_date` and `check_out_date`. Once the selection is complete, the `Customer` clicks the “Book Now” button to proceed with the booking.

2. The `Frontend` sends a `POST \bookings` request to the `ReservationService`, including all reservation parameters and the `pricing_snapshot` to <span style="color:green;font-weight:bold;background:beige;">verify price consistency at checkout</span>.

<span style="color:red;">(will make an idempotency check - add this here)</span>

3. The `ReservationService` calls the `InventoryService` to place a temporary lock on the requested rooms. <span style="color:green;font-weight:bold;background:beige;">This prevents other customers from booking the same rooms while the current booking is in progress</span>. 

	- If the lock is successful, the `ReservationService` calls the `PricingService` to validate the final booking price. <span style="color:green;font-weight:bold;background:beige;">This ensures that the customer is charged the most up-to-date amount and avoids discrepancies with the earlier displayed pricing.</span>

	- If the rooms are not available, the `ReservationService` returns an error to the `Frontend`, prompting the `Customer` to revise their selection.

4. Once the pricing is confirmed, the `ReservationService` initiates the payment process by sending a request to the `PaymentService`, which in turn communicates with an external `Payment Gateway` such as a `Bank`, `CardProcessor`, or `UPIService`.

	- If the payment succeeds, the `ReservationService` finalizes the booking by persisting the `Reservation`, updating the `InventoryService` to permanently reduce room availability and triggering the `NotificationService` to send a booking confirmation to the customer via email, SMS, or push notification.

	- If the payment fails, the `ReservationService` releases the locked rooms in `InventoryService` and notifies the `Frontend` so the `Customer` can attempt payment again or choose another method.

5. Finally, the `Frontend` displays a "Booking Confirmation" page to the `Customer` containing the reservation details along with a unique `booking_reference_id`.

<span style="color:green;font-weight:bold">Sequence Diagram</span>

```mermaid
sequenceDiagram
    participant C as Customer
    participant UI as Frontend
    participant RS as ReservationService
    participant IS as InventoryService
    participant PS as PricingService
    participant Pay as PaymentService
    participant NS as NotificationService
    
    %% Interaction 1: Customer -> Frontend
    C->>+UI: Click "Book Now" Button
    Note right of C: 1. Select RoomTypes + Quantities <br/> 2. Set Check-In and Check-Out Dates
    
    %% Interaction 2: Frontend -> ReservationService
    UI->>+RS: POST /bookings
    
    %% Interaction 3: ReservationService -> InventoryService
    RS->>+IS: Place Temporary Lock (per room type & quantity)
    IS-->>-RS: message: Lock Acquired | Lock Not Acquired
    
    alt Lock Acquired
	    %% Interaction 3: ReservationService -> PricingService
	    RS->>+PS: Validate Final Price
	    PS-->-RS: message: Price Not Changed | Price Changed
	    
	    alt Price Not Changed
		    %% Interaction 4: ReservationService -> PaymentService
		    RS->>+Pay: Process Payment
		    Pay-->-RS: message: Payment Success | Payment Failure
		    
		    alt Payment Success
			    %% Interaction 5: ReservationService -> InventoryService
			    RS->>+IS: Update Inventory
			    IS-->-RS: message: Inventory Updated and Lock Released
			    %% Interaction 6: ReservationService -> NotificationService
			    RS->>+NS: Send Booking Confirmation
			    NS-->>-RS: message: Confirmation Sent
			    RS-->UI: HTTP ? with message: Booking Confirmed
			    UI-->C: Show message: Booking Confirmed & Unique Booking ID
			else Payment Failure
				RS->>+IS: Release Lock
				IS-->-RS: Lock Released
				RS-->>UI: HTTP ? with message: Payment Failed
				UI-->>C: Show message: Payment Failed, Try Again
			end
			
		else Price Changed
			RS-->>UI: HTTP ? with message: Price Changed
			UI-->>C: Show message: Price Updated, Accept Updated Price
		end
    
    else Lock Not Acquired
	    RS-->-UI: HTTP ? with message: Rooms Unavailable (adjust selections)
	    UI-->-C: Show message: Modify Room Types / Quantities
	end
```

> **Design Choice: Keep `PricingService` separate from `InventoryService`**
> 
> The `InventoryService` should focus only on availability while the `PricingService` should handle all price-related logic such as base rates, taxes, discounts and dynamic pricing. 
> 
> Separating them ensures clear responsibilities, accurate price re-verification at checkout, and flexibility to support promotions, personalization, and advanced yield models without complicating inventory code.

<span style="color:red">(extra - include this in above explanation)</span>

The booking process is designed as a two-step flow to ensure availability and payment integrity:

1. Book Now (Initiation)
    - When the user clicks Book Now, the system creates a reservation record in PENDING status.
    - A temporary inventory hold is placed to prevent the same room from being booked by another user.
    - The API responds with a reservationId and a payment session/redirect URL, which the client uses to proceed to payment.
    
2. Pay Now (Finalization)
    
    - When the user clicks Pay Now (or when the payment gateway callback occurs), the system verifies that the inventory hold is still valid.
    - It then processes the payment request with the payment provider.
    - If successful, the temporary hold is converted into a confirmed allocation, the reservation status is updated to CONFIRMED, and payment details are persisted.
    - Notifications are triggered (e.g., email/SMS).
    - If payment fails or the hold has expired, the system releases the hold and marks the reservation as FAILED or EXPIRED.

---

<span style="color:purple;font-weight:bold;">Advantages of separating</span> **room_types (hotelDB)** <span style="color:purple;font-weight:bold;">and</span> **room_inventory (inventoryDB)**

1. **Clear service ownership / bounded context**: Each service (HotelService vs InventoryService) owns its data model and lifecycle; teams can work independently.

2. **Independent scaling and resource tuning**: <span style="color:red;font-weight:bold;">Inventory workloads (frequent writes/updates, time-series queries) can be tuned differently (IO, partitioning, retention)</span> from hotel metadata (reads, joins).

3. **Optimized storage & indexing per workload**: <span style="color:red;font-weight:bold;">Inventory can be optimized for date-range queries, partitioned by month, use different indexes or even a time-series DB; room_types stays normalized for catalog queries.</span>

4. **Reduced contention and better performance:** <span style="color:red;font-weight:bold;">High-rate inventory updates won’t lock or bloat hotel metadata tables; write-heavy inventory does not impact reads on hotel data.</span>

5. **Flexible technology choice:** <span style="color:red;font-weight:bold;">Use the best DB per need (Postgres for room_types, a time-series DB or scaled Postgres for inventory) without forcing one model on both.</span>

6. **Security and compliance separation**: Different access control, retention, or audit policies per domain (inventory may have different SLA/retention requirements).

<span style="color:purple;font-weight:bold;">Short trade-offs to be aware of:</span>

1. **No cross-DB foreign keys**: you must use stable identifiers (UUIDs) or denormalize/replicate minimal metadata.

2. **Increased operational complexity:** cross-service calls, sync/consistency, monitoring, and distributed transactions (usually avoided).

3. **Potential eventual consistency**: <span style="color:red;font-weight:bold;">need strategies: synchronous lookups, denormalized copies, or event-driven replication.</span>

---
### Booking Workflow

**Option 1:**

When user clicks `Book Now` button, a request is sent to the inventory service to create a hold with `status = CREATED` and `expiry_date = NULL` for the request and update the inventory for the selected room types (using pessimistic locking). 

- If all inventory updates succeed, update the `status = CONFIRMED` and `expiry_at = DATETIME` attributes of the created hold.

- If anything fails, all updates to the database are reverted, including the created hold.

**Idempotency Check:** In case the user clicks the `Book Now` button multiple times, the hold will ensure that no inventory updates take place if a hold is active.

If the hold has expired when the user clicks the `Pay Now` button, the payment workflow will check the hold expiry and return stating `Inventory hold expired`.

If the hold expired while the payment was in-progress:
- If the payment completes, mark the hold as confirmed.
- If the payment fails, mark the hold as cancelled and revert the inventory updates. 

---
### What happens right after Razorpay says “payment successful”?

From Razorpay / frontend you basically get:

- `razorpay_payment_id`
- `razorpay_order_id`
- `razorpay_signature`
- plus your own context: `reservationId`, `holdId`, `amount`, etc.

Now someone has to:

1. **Verify the payment** (signature, amount, status) with Razorpay.
2. **Persist the payment record** (SUCCESS / FAILED etc.).
3. **Trigger domain changes**:
    
    - finalize reservation;
    - convert / confirm inventory hold;
    - maybe send emails, invoices, loyalty points, etc.

4. Handle **weird cases**:
    
    - payment is captured but reservation confirm fails;
    - duplicate callbacks / retries;
    - refunds / partial captures later.

<span style="color:red;font-weight:bold;">All of these are deeply _payment-centric_ concerns. That’s why the payment service should drive this, not reservation.</span>

---
### Why transactions matter SO much in payment flows

**Prevent** **partial state corruption**

Imagine this horrible scenario without a transaction:

1. You verify Razorpay signature → update Payment status to `SUCCESS_CLIENT_CALLBACK`.
2. **Before** you orchestrate hold/reservation calls…
3. DB update is saved.
4. Then the method throws an exception (network issue, service down, etc.).
5. Payment record is stuck halfway:
    - It says “signature validated”
    - But reservation is not finalized
    - Hold is not consumed
    - Payment is neither `SUCCESS` nor fully `FAILED`

This is a **corrupted state** → impossible to reliably recover from.

`@Transactional` prevents this by:

- NOT committing anything until the whole method returns successfully.

**Important subtle point:** `@Transactional` does **NOT** make downstream REST calls transactional.

Those happen outside DB boundaries. But it **DOES** protect your internal state. This is how sagas are normally written:

- Local DB changes → transactional (atomic)
- External service calls → outside transaction
- If an external call fails → you handle compensation (update DB state to reflect partial failure)

Without `@Transactional`, your saga breaks.

**Example**:

Inside your method you do:

```
payment.setStatus(SUCCESS_CLIENT_CALLBACK);
paymentRepository.save(payment);

inventoryClient.consumeHold(...); // external call
reservationClient.confirmReservation(...); // external call

payment.setStatus(SUCCESS);
paymentRepository.save(payment);
```

With `@Transactional`:

- If anything fails before the method completes → **no change** is saved
- If all steps succeed → both updates are committed together

Without it:

- You could save `SUCCESS_CLIENT_CALLBACK`
- Then hit an exception
- Leaving payment stuck forever in an incomplete state

This is how bookings get into “limbo” and cost people money.

---







