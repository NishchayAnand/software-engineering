
The **Hotel Reservation System** serves as a platform connecting **customers** and **hotels**, handling all stages of the reservation process such as **searching for hotels**, **viewing hotel and room details**, and **making reservations**.

Letâ€™s discuss each use case in detail to gain a clear understanding of the systemâ€™s functionality and to evaluate the scale and capacity the platform needs to support.

---
### Use Case 1: Search Hotels

Enables **customers** to **search for available hotels** based on their specified **location** and **check-in / check-out dates**.

**Load Estimation**

```
- Assumption: Daily Active Users (DAU) = 5 Million
- Assumption: Average Search Requests per User per Day = 5

- Total Requests per Day = 5M * 5 = 25M
- Average RPS = 25,000,000 / (86,400) â‰ˆ 250 RPS

- Assumption: Peak Load Factor = 5x
- Peak RPS = 250 * 5 â‰ˆ 1,250 RPS
```

> This is a **read-heavy**, **latency-sensitive** query workload (high QPS with spiky peaks).

**Extra Information (only for reference)**

| RPS Range    | How itâ€™s perceived                    |
| ------------ | ------------------------------------- |
| < 100 RPS    | Small system / single server possible |
| 100-500 RPS  | Needs basic horizontal scaling        |
| 500-2000 RPS | Serious production system             |
| 2k-10k RPS   | Large-scale, caching mandatory        |
| 10k+ RPS     | Internet-scale systems                |
So 1250 RPS sits right in the zone where:

- Caching is mandatory
- Stateless services are mandatory
- DB isolation is mandatory
- Poor design will fail

| Company     | Approx Search RPS (peak) |
| ----------- | ------------------------ |
| MakeMyTrip  | 10k-50k RPS              |
| Booking.com | 100k+ RPS                |
| Airbnb      | 20k-40k RPS              |

Think of it like this:

> 1250 RPS is ~1â€“5% of MakeMyTripâ€™s peak search traffic.

That might sound small â€” but architecturally?

ðŸ‘‰ The design principles are the SAME

- Stateless services
- Heavy caching
- Precomputation
- Async workflows
- Horizontal scaling
- Strong observability

**Architecture Overview**

Why Search is harder than it looks

Each Search Hotels request:

- Filters by location
- Checks date range
- Computes availability
- Applies pricing rules
- Sorts results

Doing this 1250 times per second synchronously = disaster âŒ

So your architecture must ensure:
  
> Search is mostly a cache lookup, not a computation.

**Example setup**

- 6â€“8 service instances
- Redis with â‰¥90% cache hit
- 1 primary DB + read replicas

**API Design Overview**

Characteristics

- Stateless
- Horizontally scalable
- Heavy Redis usage
- Eventual consistency OK

---
### Use Case 2: View Hotel Details

Enables **customers** to **view complete details of a selected hotel**, including **amenities**, **images**, **policies**, and **room-type availability** for the specified check-in and check-out dates.

**Load Estimation**

```
- Assumption: 50% of users view details after search
- Assumption: Average View Details Requests per User per Day = 2

- Total Requests per Day = 5M * 50% * 2 = 5,000,000
- Average RPS = 5,000,000 / (86,400) â‰ˆ 50 RPS

- Assumption: Peak Load Factor = 5x
- Peak RPS = 50 * 5 â‰ˆ 250 RPS
```

This is a medium-load read-heavy use case. 50 â†’ 250 RPS is a healthy, production-grade workload that demands good caching and clean service boundaries â€” but not extreme scaling tricks.

Split **static hotel profile content** (amenities/images/policies) from **dynamic availability/pricing** so most traffic can be served from caches/CDN while keeping availability accurate.

**Extra Information (only for reference)**

| RPS       | Classification       |
| --------- | -------------------- |
| < 20 RPS  | Low load             |
| 50 RPS    | Moderate load        |
| 250 RPS   | Peak / burst traffic |
| 1000+ RPS | High scale           |

Key insight:

> View Details is ~5Ã— lighter than Search, but heavier per request

Each request:

- Loads images
- Loads amenities & policies
- Loads room availability  

So CPU & payload size > Search

At companies like Booking.com / MakeMyTrip:

- View Details RPS is often lower than Search
- But:  
	- Payloads are larger
	- Aggregation cost is higher
    
- They rely heavily on:  
	- CDN for images
	- Cache for hotel metadata
	- Partial availability caching
  
Our numbers are tiny compared to them, but the pattern is identical.

**Architecture Overview** 

At 250 RPS peak, you can safely: 

Backend

- 2â€“3 stateless service instances
- One Redis cluster
- One read replica DB

Caching strategy (critical)

- Hotel metadata â†’ cache TTL = hours
- Policies â†’ cache TTL = hours
- Amenities â†’ cache TTL = hours
- Availability â†’ cache TTL = minutes

Result:

- 80â€“90% cache hit rate
- DB load stays minimal  

**Latency expectations**

Users expect:

- <300ms backend response
- Images load progressively (via CDN)

At this RPS:
  
- Latency issues come from:  

	- Poor aggregation
	- No caching
	- Large synchronous DB joins

What could go wrong at this scale?

Even at 250 RPS, bad design can hurt:

âŒ Fetching everything synchronously
âŒ No caching for availability
âŒ Serving images from backend
âŒ N+1 DB queries

**API Design Overview**

Characteristics

- Read-heavy
- Aggregates data
- CDN-backed images
- Moderate caching

---
### Use Case 3: Make Reservations

Enables **customers** to **select a hotel and room type**, provide guest details, complete payment, and receive a confirmed booking.

**Load Estimation**

```
- Assumption: 2% of users make a booking per day
- Assumption: Average Booking Requests per User per Day = 1

- Total Requests per Day = 5M * 2% = 100,000
- Average RPS = 100,000 / (24 * 60 * 60) â‰ˆ 1 RPS

- Assumption: Peak Load Factor = 5x
- Peak RPS = 1 * 5 = 5 RPS
```

This is a classic low-QPS, high-risk use case. 1â€“5 RPS means you should design for safety, not scale.

> Simplicity + correctness beats fancy scaling tricks.

**Architecture Overview**

Service setup

- Even 1â€“2 instances can handle this load
- Autoscaling not critical
- Strong DB transactions are acceptable

Database
  
- Can use row-level locks
- Can use transactions
- Can afford strict isolation levels

At higher RPS, youâ€™d avoid these â€” but here theyâ€™re safe.

**API Design Overview**

Characteristics

- Strong consistency
- DB transactions
- Low RPS
- Idempotent writes



---
### Design Choices

The use cases exhibit **very different operational characteristics** in terms of traffic volume, read/write patterns, and consistency requirements.

| Use Case           | Avg RPS | Peak RPS | Nature                           |
| ------------------ | ------- | -------- | -------------------------------- |
| Search Hotels      | 250     | 1250     | Read-heavy, cache-driven         |
| View Hotel Details | 50      | 250      | Read-heavy, aggregation          |
| Make Reservation   | 1       | 5        | Write-heavy, strongly consistent |
These differences make it impractical to serve all use cases through a monolithic architecture.

To avoid tightly coupled workloads with vastly different scalability, latency, and consistency requirements, we will adopt a **microservices architecture**, where each major use case is implemented as an independent service. This allows high-traffic, read-heavy services such as search to scale horizontally and leverage caching, while low-traffic but critical workflows like reservations can enforce strong transactional guarantees without being impacted by unrelated load.

**Extra Information (only for reference)**

By isolating responsibilities, deployments, and data ownership, the microservices approach reduces operational risk, improves fault isolation, and enables the system to evolve and scale efficiently as demand grows.

**Data Ownership (Critical Rule):** Each service owns its own database

| Service     | DB               |
| ----------- | ---------------- |
| Search      | Read-optimized   |
| Hotel       | Metadata store   |
| Reservation | Transactional DB |


Typical funnel:

```
1000 searches
  â†“
100 detail views
  â†“
5 checkouts
  â†“
1 booking
```

**Architecture Overview**

Communication Pattern

Synchronous (REST)

- Search â†’ Cache
- Details â†’ Metadata
  
Asynchronous (Events)

- Reservation confirmed â†’ Inventory updated
- Payment success â†’ Reservation confirmed

Event bus:

- Kafka / SNS + SQS

---
