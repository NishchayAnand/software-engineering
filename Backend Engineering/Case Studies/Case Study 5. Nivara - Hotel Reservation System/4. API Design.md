
Let‚Äôs discuss the **API design of the core services** in detail, examining the main endpoints each service exposes, the request and response models they use, and the reasoning behind the underlying business logic. 

This helps clarify how responsibilities are distributed across services and how they interact to support the reservation flow.

![api-design](api-design.png)

---
### Search Service

The **Search Service** is responsible for handling the **Search Hotels** use case. It acts as a read-optimized, high-throughput service that aggregates data from multiple downstream services to return fast and relevant search results.

Below, we discuss the key endpoints exposed by the Search Service.

#### 1. `GET /hotels/hotel-listings`

Returns a read-optimized list of available hotels for a given location and date range by aggregating hotel metadata, availability, and pricing.

##### Request Parameters

| Parameter    | Type   | Description         |
| ------------ | ------ | ------------------- |
| locationId   | string | location identifier |
| checkInDate  | date   | Check-in date       |
| checkOutDate | date   | Check-out date      |
###### Sample Request 

```json
GET /hotels/hotel-listings?locationId=BLR&checkInDate=2025-03-10&checkOutDate=2025-03-12
```
###### Business Logic

```java
public List<SearchHotelView> searchHotels(
	Long locationId, 
	LocalDate checkInDate, 
	LocalDate checkOutDate
) {

	// 1. Cache lookup (short TTL)
	List<SearchHotelView> cached = cache.get(request);
	if (cached != null) {
		return cached;
	}

	// 2. Fetch hotels for location
	List<HotelDTO> hotels =
			hotelClient.getHotelsByLocation(locationId);

	if (hotels.isEmpty()) {
		return Collections.emptyList();
	}

	List<Long> hotelIds =
			hotels.stream().map(HotelDTO::getHotelId).toList();

	// 3. Batch availability check
	AvailabilityResponse availability =
			inventoryClient.checkAvailability(
					hotelIds,
					request.getCheckInDate(),
					request.getCheckOutDate()
			);

	// 4. Filter available hotels
	List<String> availableHotelIds =
			availability.getAvailableHotelIds();

	if (availableHotelIds.isEmpty()) {
		return Collections.emptyList();
	}

	// 5. Batch pricing call
	Map<String, BigDecimal> pricing =
			pricingClient.getAvgPrices(
					availableHotelIds,
					request.getCheckInDate(),
					request.getCheckOutDate()
			);

	// 6. Aggregate response
	List<SearchHotelView> results = hotels.stream()
			.filter(h -> availableHotelIds.contains(h.getHotelId()))
			.map(h -> SearchHotelView.from(h, pricing.get(h.getHotelId())))
			.toList();

	// 7. Cache result (short TTL)
	cache.put(request, response);

	return results;
}
```
###### Sample Response

```json
[
  {
    "hotelId": 101,
    "name": "Grand Goa Resort",
    "address": "Candolim Beach Road, Goa, India",
    "thumbnailUrl": "https://cdn.example.com/101/thumb.jpg",
    "rating": 4,
    "avgPricePerNight": 4500,
  },
  {
    "hotelId": 102,
    "name": "City Budget Inn",
    "address": "MG Road, Bengaluru, India",
    "thumbnailUrl": "https://cdn.example.com/102/thumb.jpg",
    "rating": 3,
    "avgPricePerNight": 2200,
  }
]
```

**(only for reference)**

Calling "SearchHotelView" a ‚ÄúView‚Äù signals:

> _This is an aggregated, read-only representation assembled for presentation._

---
### Hotel Service

The **Hotel Service** is responsible for owning and serving **static hotel profile data**. This data changes infrequently, is optimized for read-heavy access through aggressive caching with long TTLs, and intentionally excludes dynamic information such as availability and pricing.

Let's discuss the key endpoints exposed by the Reservation Service.

#### `1. GET /hotels`

Returns a list of hotels for a given location.

##### Request Parameters

| Parameter  | Type   | Required | Description                                           |
| ---------- | ------ | -------- | ----------------------------------------------------- |
| locationId | String | Yes      | City or location identifier (e.g., city code or name) |
##### Sample Request

```json
GET /hotels?location=BLR
```

##### Business Logic

```java
@Cacheable(
	value = "hotelsByLocation",
	key = "#locationId",
	unless = "#result.isEmpty()"
)
public List<HotelSummaryResponse> getHotelsByLocation(String locationId) {

	return hotelRepository.findByLocation(locationId)
			.stream()
			.map(HotelSummaryResponse::from)
			.toList();
}
```

##### Sample Response

```json
[
  {
    "hotelId": 101,
    "name": "Grand Goa Resort",
    "description": "A luxury seaside resort offering modern rooms, infinity 
				    pool, and beach access.",
    "locationId": "GOA",
    "address": "Candolim Beach Road, Goa, India",
    "thumbnailUrl": "https://cdn.example.com/101/thumb.jpg",
    "rating": 4.6,
    "amenities": ["wifi", "pool", "gym", "spa"]
  },
  {
    "hotelId": 102,
    "name": "Westin Resort",
    "description": "Premium 5-star property featuring private beach, fine 
					dining, and wellness spa.",
    "locationId": "GOA",
    "address": "Arpora Beach Road, Goa, India",
    "thumbnailUrl": "https://cdn.example.com/102/thumb.jpg",
    "rating": 4.7,
    "amenities": ["wifi", "pool", "private beach", "restaurant", "bar"]
  }
]
```

This endpoint is **read-optimized** and used primarily by the **Search Service** to fetch static hotel metadata.
#### `2. GET /hotel/{hotelId}`

Returns the full hotel profile for a given hotel.

##### Sample Request

```json
GET /hotels/H123
```

##### Business Logic

```java
@Cacheable(
	value = "hotelDetails",
	key = "#hotelId"
)
public HotelDetailsResponse getHotelDetails(String hotelId) {

	Hotel hotel = hotelRepository.findByHotelId(hotelId)
			.orElseThrow(() -> new NotFoundException("Hotel not found"));

	return HotelDetailsResponse.from(hotel);
}
```

##### Sample Response

```java
{
  "hotelId": "H123",
  "name": "Ocean View Hotel",
  "location": "Bangalore",
  "description": "A beachfront hotel offering scenic views and premium amenities.",
  "rating": 4.5,
  "amenities": [
    "Free Wi-Fi",
    "Swimming Pool",
    "Breakfast Included",
    "Parking"
  ],
  "imageUrls": [
    "https://cdn.example.com/hotels/H123/1.jpg",
    "https://cdn.example.com/hotels/H123/2.jpg"
  ],
  "policies": {
    "checkInTime": "14:00",
    "checkOutTime": "11:00",
    "cancellation": "Free cancellation up to 24 hours before check-in"
  },
  "roomTypes": [
    {
      "code": "DELUXE",
      "name": "Deluxe Room",
      "capacity": 2,
      "description": "Spacious room with sea view"
    },
    {
      "code": "STANDARD",
      "name": "Standard Room",
      "capacity": 2,
      "description": "Comfortable room with city view"
    }
  ]
}
```

This endpoint serves **static, read-only hotel metadata** required to render the hotel details page.

---
### Reservation Service

The **Reservation Service** is responsible for managing the **booking lifecycle**, including reservation creation, inventory locking coordination, and reservation state transitions. 

It owns the **reservation state machine** and ensures that bookings are created safely before payment is initiated. Below are the **reservation states** managed by the Reservation Service:

- `INITIATED`: Reservation record created (idempotency anchor)
- `PENDING_PAYMENT`: Inventory successfully held, awaiting payment
- `CONFIRMED`: Booking finalized after successful payment
- `EXPIRED` / `FAILED`: Reservation invalidated due to timeout or failure

Now, let's discuss the key endpoints exposed by the Reservation Service.
#### 1. `POST /reservations`

Creates a new reservation request and initiates **Phase 1: Reservation Initiation & Inventory Hold**.

##### Request Parameters

| Field        | Type   | Description                          |
| ------------ | ------ | ------------------------------------ |
| requestId    | string | Client-generated idempotency key     |
| hotelId      | string | Selected hotel identifier            |
| checkInDate  | date   | Check-in date                        |
| checkOutDate | date   | Check-out date                       |
| rooms        | map    | Room types with requested quantities |
##### Sample Request

```json
{
  "requestId": "req-12345",
  "hotelId": "H123",
  "checkInDate": "2025-03-10",
  "checkOutDate": "2025-03-12",
  "rooms": {
	"DELUXE": 2,
	"STANDARD": 1
  }
}
```

##### Business Logic

```java
@Transactional
public Reservation createReservation(
	String requestId, 
    Long hotelId, 
    LocalDate checkInDate,
    LocalDate checkOutDate,
    Map<String, Integer> rooms,
) {

	// 1. Idempotency check
	Optional<Reservation> existing =
			reservationRepository.findByRequestId(requestId);

	if (existing.isPresent()) {
		return ReservationResponse.from(existing.get());
	}

	// 2. Create reservation record (INITIATED)
	Reservation reservation = Reservation.builder()
			.requestId(requestId)
			.hotelId(getHotelId)
			.checkInDate(checkInDate)
			.checkOutDate(checkOutDate)
			.rooms(rooms)
			.status(ReservationStatus.INITIATED)
			.build();

	reservationRepository.save(reservation);

	// 3. Call InventoryService (batch hold)
	InventoryHoldResponse holdResponse =
			inventoryClient.placeHold(
					InventoryHoldRequest.from(reservation)
			);

	// 4. Update reservation on successful hold
	reservation.setStatus(ReservationStatus.PENDING_PAYMENT);
	reservation.setHoldId(holdResponse.getHoldId());
	reservation.setHoldExpiresAt(holdResponse.getExpiresAt());

	reservationRepository.save(reservation);

	return reservation;
}
```

`@Transactional` guarantees that the idempotency check, reservation record creation, and state transition from `INITIATED` to `PENDING_PAYMENT` are committed together, preventing partially persisted or inconsistent booking state. 

If any step fails, the transaction is rolled back automatically, preserving data integrity.

###### Sample Response

```json
{
  "reservationId": "R789",
  "status": "PENDING_PAYMENT",
  "inventoryHold": {
    "holdId": "HOLD456",
    "expiresAt": "2025-03-10T12:15:00Z"
  }
}
```

#### 2. POST /reservations/{reservationId}/confirm

Finalizes a reservation after **successful payment and inventory finalization**.

##### Sample Request

```json
POST /reservations/R789/confirm
Content-Type: application/json

{
  "paymentId": "pay_987654",
  "orderId": "order_123456",
  "paymentProvider": "RAZORPAY",
  "paidAt": "2025-03-10T10:15:30Z"
}
```

##### Business Logic

```java
@Transactional
public ReservationConfirmationResponse confirmReservation(
		String reservationId,
		PaymentConfirmationRequest request
) {
	Reservation reservation = reservationRepository
			.findById(reservationId)
			.orElseThrow(() ->
					new NotFoundException("Reservation not found")
			);

	// Idempotency: already confirmed
	if (reservation.getStatus() == ReservationStatus.CONFIRMED) {
		return ReservationConfirmationResponse.from(reservation);
	}

	// Validate state
	if (reservation.getStatus() != ReservationStatus.PENDING_PAYMENT) {
		throw new IllegalStateException(
				"Invalid state transition for reservation: " + reservation.getStatus()
		);
	}

	// Persist payment details
	reservation.setPaymentId(request.getPaymentId());
	reservation.setPaymentOrderId(request.getOrderId());
	reservation.setPaymentProvider(request.getPaymentProvider());
	reservation.setPaidAt(request.getPaidAt());

	// Transition state
	reservation.setStatus(ReservationStatus.CONFIRMED);
	reservation.setConfirmedAt(Instant.now());

	reservationRepository.save(reservation);

	return ReservationConfirmationResponse.from(reservation);
}
```

If duplicate or retried confirmation requests arrive (which is common with payment callbacks), `@Transactional` ensures that state checks and updates are executed consistently, so the reservation cannot be confirmed twice or left in an intermediate state.

##### Sample Response Body

```json
{
  "reservationId": "R789",
  "status": "CONFIRMED",
  "confirmedAt": "2025-03-10T10:15:35Z"
}
```

This endpoint is invoked **only by the PaymentService** during **Phase 2**.

>**(only for reference)**
>
> The `requestId` parameter will act as an idempotency key, allowing system to prevent double booking in case the same user clicks on the `Book Now` button multiple times. The `requestId` usually expires after a certain period of time. 
> 
> The `requestId` could be a combination of the items selected or can be generated by a globally unique ID generator. A UUID is commonly used as an idempotency key and it is recommended by many tech companies such as Stripe and Paypal.
> 
> If multiple concurrent requests are detected with the same idempotency key, only one request is processed and the others receive a `429 Too Many Requests` status code.
>
> **NOTE:** Idempotency is key to ensure the at-most-one guarantee.
>
> To avoid duplicate work when a client retries the same booking request, every reservation flow must include an idempotency mechanism. This is done by requiring a client-generated `requestId` (typically a UUID) for each booking attempt and persisting a reservation request with `PENDING` status. 
>
> If a record already exists, the `ReservationService` simply returns the stored result. If no record exists, the service creates one with status: `PENDING` in an atomic operation to prevent race conditions from simultaneous retries. 
>
> This approach ensures customers are never charged twice for the same booking, and retried requests always return consistent, deterministic results rather than triggering duplicate flows.

---
### Inventory Service

The **Inventory Service** manages the complete lifecycle of room inventory, including availability checks, temporary holds during booking, and final confirmation or release of inventory. Its primary responsibility is to enforce **strong consistency** so that overbooking is impossible even under high concurrency.

Each inventory record represents availability at the granularity of **`(hotelId, roomType, date)`**.
This allows the system to correctly handle bookings that span multiple dates.

#### Inventory Record

```java
@Entity
@Getter @Setter
public class Inventory {

    @Id
    @GeneratedValue
    private Long id;

    private String hotelId;
    private String roomType;
    private LocalDate date;

    private Integer totalCount;
    private Integer reservedCount;

    private String holdId;
    private Instant holdExpiresAt;

    public int getAvailableCount() {
        return totalCount - reservedCount;
    }

    public void hold(String holdId, Instant expiry, int qty) {
        this.reservedCount += qty;
        this.holdId = holdId;
        this.holdExpiresAt = expiry;
    }

    public void release(int qty) {
        this.reservedCount -= qty;
        this.holdId = null;
        this.holdExpiresAt = null;
    }

    public void confirm() {
        this.holdId = null;
        this.holdExpiresAt = null;
    }
}
```

Let's discuss the key endpoints exposed by the Inventory Service.

#### 1. `POST /availability/batch`

During hotel search, the system checks availability for **multiple hotels in batch**, allowing the Search Service to efficiently filter eligible hotels without incurring N+1 calls.

##### Sample Request

```json
POST /availability/batch
Content-Type: application/json

{
  "hotelIds": ["H123", "H456", "H789"],
  "checkInDate": "2025-03-10",
  "checkOutDate": "2025-03-12"
}
```

##### Business Logic

```java
@Transactional(readOnly = true)
public BatchAvailabilityResponse checkBatchAvailability(
        BatchAvailabilityRequest request
) {
    List<Inventory> inventory =
            inventoryRepository.findInventoryForHotels(
                    request.getHotelIds(),
                    request.getCheckInDate(),
                    request.getCheckOutDate()
            );

    Map<String, Boolean> availabilityByHotel = new HashMap<>();

    for (String hotelId : request.getHotelIds()) {

        boolean hasAvailability = inventory.stream()
                .anyMatch(record ->
                        record.getHotelId().equals(hotelId) &&
                        record.getAvailableCount() > 0
                );

        availabilityByHotel.put(hotelId, hasAvailability);
    }

    return new BatchAvailabilityResponse(availabilityByHotel);
}
```

##### Repository Query

```java
@Query("""
    SELECT i FROM Inventory i
    WHERE i.hotelId IN :hotelIds
      AND i.reservationDate >= :checkInDate
      AND i.reservationDate < :checkOutDate
""")
List<Inventory> findInventoryForHotels(
        List<String> hotelIds,
        LocalDate checkInDate,
        LocalDate checkOutDate
);
```

##### Sample Response

```json
{
  "availability": {
    "H123": {
      "available": true
    },
    "H456": {
      "available": false
    },
    "H789": {
      "available": true
    }
  }
}
```

The batch availability API performs a fast, coarse-grained availability check across multiple hotels without room-level details, optimized for the Search Hotels flow.

> **(only for reference)**
>
> <span style="color:red;font-weight:bold;">Q. should we do the night count check in the sql or fetch all inventory records available for the specified hotels in the checkInDate-checkOutDate daterange and then perform groupby and filtering in the application code?</span>
>
> - Minimizes data transfer and memory/CPU in the app (DB is much better at aggregations).
> - Uses indexes and query planner; much faster for large hotel/date ranges.
> - Keeps logic atomic and simpler in service code (one DB call returns only matching room types).
> - App-side grouping is only reasonable for very small datasets or if you need complex non-SQL logic.
>
> When you might do it in application code
>
> - Dataset is tiny (few hotels / short ranges) and you prefer simpler SQL.
> - You need complex business logic that‚Äôs hard to express in SQL.
> - You already cache full per-date inventory in-app and want to reuse it.

#### 2. `POST /inventory/hold`

Places a temporary hold on room inventory to prevent double booking during payment. The hold is **time-bound** and automatically expires if payment is not completed, making it safe and self-healing.

##### Sample Request

```json
POST /inventory/hold
Content-Type: application/json

{
  "reservationId": "R789",
  "hotelId": "H123",
  "checkInDate": "2025-03-10",
  "checkOutDate": "2025-03-12",
  "rooms": {
    "DELUXE": 2,
    "STANDARD": 1
  }
}
```

##### Business Logic

```java
@Transactional
public InventoryHoldResponse placeHold(InventoryHoldRequest request) {

    List<Inventory> inventory =
            inventoryRepository.lockInventory(
                    request.getHotelId(),
                    request.getRoomTypes(),
                    request.getCheckInDate(),
                    request.getCheckOutDate()
            );

    // Validate availability using derived availability
    for (Inventory item : inventory) {
        int requiredQty = request.getQuantity(item.getRoomType());

        if (item.getAvailableCount() < requiredQty) {
            throw new InventoryUnavailableException();
        }
    }

    String holdId = UUID.randomUUID().toString();
    Instant expiry = Instant.now().plus(Duration.ofMinutes(15));

    // Apply holds
    inventory.forEach(item -> {
        int qty = request.getQuantity(item.getRoomType());
        item.hold(holdId, expiry, qty);
    });

    return new InventoryHoldResponse(holdId, expiry);
}
```

##### Repository Query

```java
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("""
	SELECT i FROM Inventory i
	WHERE i.hotelId = :hotelId
	  AND i.roomType IN :roomTypes
	  AND i.date BETWEEN :checkIn AND :checkOut
""")
List<Inventory> lockInventory(
		String hotelId,
		List<String> roomTypes,
		LocalDate checkIn,
		LocalDate checkOut
);
```

##### Sample Success Response

```json
{
  "holdId": "HOLD456",
  "expiresAt": "2025-03-10T12:15:00Z"
}
```

##### Sample Failure Response (Insufficient Inventory)

```json
HTTP/1.1 409 Conflict
Content-Type: application/json

{
  "error": "INSUFFICIENT_INVENTORY",
  "message": "Not enough available rooms for DELUXE between 2025-03-10 and 2025-03-12"
}
```

Pessimistic locking is ideal for inventory holds because the operations are write-heavy, highly contended, and require strict correctness guarantees.

>**(only for reference)**
>
>Pessimistic Locking
> - Rows representing inventory (hotelId + roomType + date) are **locked immediately** when read.
> - Other concurrent transactions attempting to modify the same rows must **wait** or **fail**.
> - Typically implemented using `SELECT ‚Ä¶ FOR UPDATE`.
>
> Why it fits Inventory Holds
>
> Inventory holds are:
>
>- **Write-heavy**
>- **Highly contended**
>- **Correctness-critical**
>
> Multiple users may try to book the **same room type for the same dates at the same time**. With pessimistic locking:
>
>- Only one request can successfully place a hold.
>- Competing requests are serialized.
>- Overbooking is **impossible by design**.
>
>Once locked:
>
>- Availability is validated
>- Hold is placed atomically
>- Lock is released at transaction commit
>
> Optimistic Locking
>
>- No lock is taken when reading data.
>- A **version field** is checked during update.
>- If the version has changed, the update fails and must be retried.
>
> Why it‚Äôs risky for inventory
>
> Optimistic locking works best when:
>
 - Conflicts are rare
 >- Reads vastly outnumber writes
>
>Inventory booking violates both assumptions:
>
>- Conflicts are **frequent** (popular hotels, peak dates)
>- Writes are common during booking spikes
>
>This leads to:
>
>- High retry rates
>- Increased latency
>- Poor user experience
>- Complex retry logic

#### 3. `POST /inventory/confirm`

Responsible for **converting a temporary inventory hold into a permanent reservation**. It is invoked during **Phase 2: Payment Processing & Reservation Confirmation**, after payment has been successfully verified.

At this point:

- The user has paid
- Inventory has already been held
- The system must now **make the hold permanent**

##### Sample Request

```json
POST /inventory/confirm
Content-Type: application/json

{
  "holdId": "HOLD456",
  "reservationId": "R789"
}
```

##### Business Logic

```java
@Transactional
public InventoryConfirmResponse confirmHold(
		InventoryConfirmRequest request
) {
	List<Inventory> inventory =
			inventoryRepository.findByHoldId(
					request.getHoldId()
			);

	if (inventory.isEmpty()) {
		throw new IllegalStateException(
				"Hold not found or already released"
		);
	}

	// Idempotency: already confirmed
	boolean alreadyConfirmed = inventory.stream()
			.allMatch(i -> i.getHoldId() == null);

	if (alreadyConfirmed) {
		return new InventoryConfirmResponse(
				request.getHoldId(),
				"CONFIRMED"
		);
	}

	// Validate hold expiry
	Instant now = Instant.now();
	for (Inventory item : inventory) {
		if (item.getHoldExpiresAt().isBefore(now)) {
			throw new IllegalStateException(
					"Hold expired"
			);
		}
	}

	// Finalize inventory
	inventory.forEach(Inventory::confirm);

	inventoryRepository.saveAll(inventory);

	return new InventoryConfirmResponse(
			request.getHoldId(),
			"CONFIRMED"
	);
}
```

##### Sample Success Response

```json
HTTP/1.1 200 OK
Content-Type: application/json

{
  "holdId": "HOLD456",
  "status": "CONFIRMED"
}
```

##### Sample Failure Response

```json
HTTP/1.1 409 Conflict
Content-Type: application/json

{
  "error": "HOLD_EXPIRED",
  "message": "Inventory hold has expired or does not exist"
}
```

No availability counters are recalculated here. **Finalization is a metadata transition**, not a quantity change.

#### 4. `POST /inventory/release`

responsible for **reverting a temporary inventory hold** when a booking cannot be completed. This ensures that rooms are returned to the available pool and can be booked by other users.

##### Sample Request

```json
POST /inventory/release
Content-Type: application/json

{
  "holdId": "HOLD456",
  "reservationId": "R789",
  "reason": "PAYMENT_FAILED"
}
```

##### Business Logic

```java
@Transactional
public InventoryReleaseResponse releaseHold(
		InventoryReleaseRequest request
) {
	List<Inventory> inventory =
			inventoryRepository.findByHoldId(
					request.getHoldId()
			);

	// Idempotency: already released
	if (inventory.isEmpty()) {
		return new InventoryReleaseResponse(
				request.getHoldId(),
				"RELEASED"
		);
	}

	// Release inventory
	inventory.forEach(item -> {
		int qty = item.getReservedCountForHold(
				request.getHoldId()
		);
		item.release(qty);
	});

	inventoryRepository.saveAll(inventory);

	return new InventoryReleaseResponse(
			request.getHoldId(),
			"RELEASED"
	);
}
```

##### Sample Success Response

```json
HTTP/1.1 200 OK
Content-Type: application/json

{
  "holdId": "HOLD456",
  "status": "RELEASED"
}
```

##### Sample Failure Response

```json
HTTP/1.1 404 Not Found
Content-Type: application/json

{
  "error": "HOLD_NOT_FOUND",
  "message": "Inventory hold does not exist or was already released"
}
```

This endpoint plays a critical role in keeping inventory **accurate, self-healing, and leak-free**.

---
### Pricing Service

The **Pricing Service** is responsible for **computing room prices** for a given hotel, date range, and room type. Key endpoints include:

#### 1. `POST /pricing/batch`

A **bulk endpoint** that returns the **average per-night price per hotel** across multiple hotel IDs.

##### Sample Response

```json
POST /pricing/batch/
Content-Type: application/json

{
  "hotelIds": ["H123", "H456", "H789"],
  "checkInDate": "2025-03-10",
  "checkOutDate": "2025-03-12"
}
```

##### Business Logic

```java
@Transactional(readOnly = true)
public AvgPriceBatchResponse calculateAvgPerNightPrices(
		AvgPriceBatchRequest request
) {
	Map<String, BigDecimal> priceMap = new HashMap<>();

	for (String hotelId : request.getHotelIds()) {

		List<BigDecimal> baseRates =
				rateRepository.getBaseRatesForHotel(hotelId);

		BigDecimal avgBaseRate =
				baseRates.stream()
						 .reduce(BigDecimal.ZERO, BigDecimal::add)
						 .divide(
							 BigDecimal.valueOf(baseRates.size()),
							 RoundingMode.HALF_UP
							 );

		BigDecimal adjustedRate =
				ruleEngine.applyRules(
						avgBaseRate,
						request.getCheckInDate(),
						request.getCheckOutDate()
				);

		priceMap.put(hotelId, adjustedRate);
	}

	return new AvgPriceBatchResponse("INR", priceMap);
}
```

##### Sample Response

```json
{
  "currency": "INR",
  "prices": {
    "H123": {
      "avgPerNightPrice": 4200
    },
    "H456": {
      "avgPerNightPrice": 5100
    },
    "H789": {
      "avgPerNightPrice": 3900
    }
  }
}
```

This bulk average price API is used **only by the Search Service**.

#### 2. `POST /pricing`

Calculates prices for available room types over a date range.

##### Sample Request

```json
POST /pricing
Content-Type: application/json

{
  "hotelId": "H123",
  "checkInDate": "2025-03-10",
  "checkOutDate": "2025-03-12",
  "roomTypes": ["DELUXE", "STANDARD"]
}
```

##### Business Logic

```java
@Transactional(readOnly = true)
public PricingResponse calculatePricing(PricingRequest request) {

	Map<String, RoomPricing> pricingMap = new HashMap<>();

	for (String roomType : request.getRoomTypes()) {

		BigDecimal baseRate =
				rateRepository.getBaseRate(
						request.getHotelId(),
						roomType
				);

		BigDecimal adjustedRate =
				ruleEngine.applyRules(
						baseRate,
						request.getCheckInDate(),
						request.getCheckOutDate()
				);

		long nights =
				ChronoUnit.DAYS.between(
						request.getCheckInDate(),
						request.getCheckOutDate()
				);

		BigDecimal total = adjustedRate.multiply(
				BigDecimal.valueOf(nights)
		);

		BigDecimal taxes = taxService.calculate(total);

		pricingMap.put(
				roomType,
				new RoomPricing(
						adjustedRate,
						total,
						taxes,
						total.add(taxes)
				)
		);
	}

	return new PricingResponse(
			request.getHotelId(),
			"INR",
			pricingMap
	);
}
```

##### Response Body

```json
{
  "hotelId": "H123",
  "currency": "INR",
  "pricing": {
    "DELUXE": {
      "perNightPrice": 5000,
      "totalPrice": 10000,
      "taxes": 1200,
      "finalPrice": 11200
    },
    "STANDARD": {
      "perNightPrice": 3500,
      "totalPrice": 7000,
      "taxes": 840,
      "finalPrice": 7840
    }
  }
}
```

**(only for reference)**

we need to execute the following query:

```
WITH combos(hotel_id, room_type_id) AS (VALUES (1,1), (2,4), (3,7), (3,8))
SELECT c.hotel_id, c.room_type_id, ROUND(AVG(r.rate)) AS avg_rate_per_night
FROM combos c
LEFT JOIN room_type_rate r
	ON c.hotel_id = r.hotel_id
	AND c.room_type_id = r.room_type_id
	AND r.reservation_date >= DATE '2025-10-07'
	AND r.reservation_date < DATE '2025-10-09'
GROUP BY c.hotel_id, c.room_type_id;
```

```
public double getAvgPricePerNight(String hotelId, 
									String roomTypeId, 
									LocalDate checkInDate, 
									LocalDate checkOutDate) {

	List<PricingRecord> priceList = 
		pricingRepository.getPriceByRoomTypeAndDateRange(hotelId, roomTypeId, 
													checkInDate, checkOutDate);

	double totalPrice = priceList.stream()
		.mapToDouble(PricingRecord::getPrice).sum();

	return totalPrice / priceList.size();

}
```

---
### Payment Service

The **Payment Service** is responsible for **payment orchestration**. It manages interactions with **external payment gateways**, handles retries and callbacks, and coordinates downstream services to **safely finalize a booking after payment**.

Let's discuss the key endpoints exposed by the Payment Service.

#### 1. `POST /payments/order`

Creates a payment gateway order and returns a checkout URL.

##### Sample Request

```json
POST /payments/order
Content-Type: application/json

{
  "reservationId": "R789",
  "amount": 11200,
  "currency": "INR",
  "paymentProvider": "RAZORPAY",
  "returnUrl": "https://app.example.com/payment/return"
}
```

##### Failure Scenarios

|Scenario|Outcome|
|---|---|
|Invalid reservation state|409 Conflict|
|Duplicate request|Existing order returned|
|Gateway failure|No payment record persisted|

##### Business Logic

```java
@Transactional
public PaymentOrderResponse createOrder(
		PaymentOrderRequest request
) {
	// 1. Validate reservation state
	ReservationSnapshot reservation =
			reservationClient.getReservation(
					request.getReservationId()
			);

	if (!reservation.isPendingPayment()) {
		throw new IllegalStateException(
				"Reservation not eligible for payment"
		);
	}

	// 2. Idempotency: existing payment order
	Optional<Payment> existing =
			paymentRepository.findByReservationId(
					request.getReservationId()
			);

	if (existing.isPresent()) {
		return PaymentOrderResponse.from(existing.get());
	}

	// 3. Create payment order with gateway
	GatewayOrder gatewayOrder =
			gatewayClient.createOrder(
					request.getAmount(),
					request.getCurrency(),
					request.getReturnUrl()
			);

	// 4. Persist payment record
	Payment payment = new Payment();
	payment.setReservationId(request.getReservationId());
	payment.setPaymentOrderId(gatewayOrder.getOrderId());
	payment.setStatus(PaymentStatus.CREATED);
	payment.setAmount(request.getAmount());
	payment.setCurrency(request.getCurrency());
	payment.setProvider(request.getPaymentProvider());
	payment.setCreatedAt(Instant.now());

	paymentRepository.save(payment);

	// 5. Return checkout details
	return PaymentOrderResponse.from(payment, gatewayOrder);
}
```

##### Sample Response

```json
HTTP/1.1 200 OK
Content-Type: application/json

{
  "paymentOrderId": "order_123456",
  "checkoutUrl": "https://checkout.razorpay.com/v1/checkout.js?order_id=order_123456",
  "expiresAt": "2025-03-10T12:15:00Z"
}

```

This endpoint is invoked when the user clicks **‚ÄúPay Now‚Äù** and marks the start of **Phase 2: Payment Processing**.

#### 2. `POST /payments/confirm`

Verifies payment and finalizes the booking.

##### Sample Request

```json
POST /payments/confirm
Content-Type: application/json

{
  "reservationId": "R789",
  "paymentOrderId": "order_123456",
  "paymentId": "pay_987654",
  "paymentProvider": "RAZORPAY",
  "signature": "gateway_signature_value"
}
```

##### Business Logic

```java
@Transactional
public PaymentConfirmationResponse confirmPayment(
		PaymentConfirmRequest request
) {
	Payment payment = paymentRepository
			.findByPaymentOrderId(request.getPaymentOrderId())
			.orElseThrow(() ->
					new IllegalStateException("Payment order not found")
			);

	// Idempotency: already processed
	if (payment.getStatus() == PaymentStatus.SUCCESS) {
		return PaymentConfirmationResponse.success(
				payment.getReservationId()
		);
	}

	// 1. Verify payment with gateway
	gatewayClient.verifyPayment(
			request.getPaymentOrderId(),
			request.getPaymentId(),
			request.getSignature()
	);

	// 2. Finalize inventory
	inventoryClient.confirmHold(payment.getHoldId());

	// 3. Confirm reservation
	reservationClient.confirmReservation(
			payment.getReservationId(),
			request.getPaymentId(),
			request.getPaymentOrderId(),
			request.getPaymentProvider()
	);

	// 4. Update payment state
	payment.setStatus(PaymentStatus.SUCCESS);
	payment.setPaymentId(request.getPaymentId());
	payment.setCompletedAt(Instant.now());

	paymentRepository.save(payment);

	return PaymentConfirmationResponse.success(
			payment.getReservationId()
	);
}
```

##### Sample Response

```
HTTP/1.1 200 OK
Content-Type: application/json

{
  "reservationId": "R789",
  "paymentStatus": "SUCCESS",
  "bookingStatus": "CONFIRMED"
}
```

**(only for reference)**

```
{
	"reservationId": "resv_789456123",
	"status": "PENDING",
	"hold": {
		"holdId": "hold_12345",
		"expiresAt": "2025-09-25T14:30:00Z"
	},
	"pricing": {
		"currency": "INR",
		"totalAmount": 18500,
		"breakdown": [
			{
				"roomTypeId": "deluxe_king",
				"nights": 2,
				"pricePerNight": 9250
			}
		]
	},
	"payment": {
	    "paymentSessionId": "pay_sess_987654",
		"redirectUrl": "https://psp.example.com/pay/session/pay_sess_987654"
	}
}
```

The system requires the `reservationId` and `holdId` in the next step (when finalizing/payment) to identify the reservation it's trying to complete and ensure the selected rooms are still reserved.

> **IMPORTANT:** before persisting payment check if the hold is still valid.

---
### Why do we need a¬†`created_at`¬†attribute?

The¬†`created_at`¬†field records the¬†**exact timestamp when a record was first inserted**¬†into the database.

| Purpose                              | Description                                                                                           |
| ------------------------------------ | ----------------------------------------------------------------------------------------------------- |
| üïí¬†**Auditing & traceability**       | Know¬†_when_¬†something (e.g., booking, user, payment, or hold) was created.                            |
| üìä¬†**Analytics & reporting**         | <span style="color:red;">Measure growth trends ‚Äî bookings/day, users/week, etc.</span>                |
| ‚öôÔ∏è¬†**Debugging & troubleshooting**   | Helps reconstruct events ‚Äî¬†_‚ÄúWhen did this hold start?‚Äù_¬†or¬†_‚ÄúHow long did it last before expiring?‚Äù_ |
| üîÑ¬†**TTL-based cleanup**             | Crucial for background jobs ‚Äî e.g., expire holds after 15 minutes from¬†`created_at`.                  |
| üì¶¬†**Data versioning & replication** | Sync only new or updated rows.                                                                        |
| üîê¬†**Compliance / audit logs**       | Required for regulatory traceability in fintech or booking systems.                                   |

---
### Late payment attempts (very important)

If a payment attempt arrives after expiry:

- Reject with a clear response:
    
    - HTTP¬†`409 Conflict`¬†or¬†`410 Gone`¬†(choose standard; 410 indicates resource expired)
    - Body:¬†`{ code: "HOLD_EXPIRED", message: "Hold expired at 2025-10-25T10:32:00Z" }`

- If payment was already authorized by the gateway but hold expired before capture:
    
    - **Void / cancel**¬†the authorization immediately (call payment gateway void endpoint).
    - Refund if capture already happened (should be avoided by design).

- Record the outcome and notify the user.

---

Let me walk you through the real reason behind returning:

- holdId
- reservationId
- paymentId

in the response of **consumeHold**, even though the caller already knows these values.

Imagine payment-service calls:

```
POST /holds/{holdId}/consume
```

and right after consuming the hold, the network dies / timeout happens.

payment-service does not know if:

- the hold was actually consumed OR
- the request failed before the DB write OR
- something partially happened OR
- retry will double-consume inventory

So it retries.

When inventory-service returns:

```
{
  "holdId": 123,
  "status": "CONSUMED",
  "reservationId": 456,
  "paymentId": "pay_...",
}
```

the payment-service can verify:

- Is this the same payment as I am trying now?
- Does the consumed hold belong to the same reservation?
- Did the previous attempt succeed completely?

This lets the payment-service do clean idempotent logic:

```
if (response.paymentId == myPaymentId && response.reservationId == myReservationId)
    // Safe retry; workflow succeeded previously
else 
    // Something is wrong; possible conflict
```

Without returning these fields, the client would have no way to distinguish:

- valid idempotent success from stale / conflicting / incorrect consumption
  
Huge safety benefit.

---
### Release Hold Functionality

When you ‚Äúrelease a hold‚Äù you‚Äôre basically saying:

> ‚ÄúThis temporary lock on inventory is no longer needed. Put the rooms back into the pool so other customers can book them, and mark this hold as released.‚Äù