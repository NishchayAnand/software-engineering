
Let‚Äôs discuss the **API design of the core services** in detail, examining the main endpoints each service exposes, the request and response models they use, and the reasoning behind the underlying business logic. 

This helps clarify how responsibilities are distributed across services and how they interact to support the reservation flow.

![api-design](api-design.png)

---
### Search Service

The **Search Service** is responsible for handling the **Search Hotels** use case. It acts as a read-optimized, high-throughput service that aggregates data from multiple downstream services to return fast and relevant search results.

#### Endpoint 1

```
GET /hotels/hotel-listings
```

##### Request Parameters

| Parameter    | Type   | Description         |
| ------------ | ------ | ------------------- |
| locationId   | string | location identifier |
| checkInDate  | date   | Check-in date       |
| checkOutDate | date   | Check-out date      |
###### Sample Request

```
GET /hotels/hotel-listings?locationId=BLR&checkInDate=2025-03-10&checkOutDate=2025-03-12
```
###### Business Logic

```
public List<SearchHotelView> searchHotels(
	Long locationId, 
	LocalDate checkInDate, 
	LocalDate checkOutDate
) {

	// 1. Cache lookup (short TTL)
	List<SearchHotelView> cached = cache.get(request);
	if (cached != null) {
		return cached;
	}

	// 2. Fetch hotels for location
	List<HotelDTO> hotels =
			hotelClient.getHotelsByLocation(locationId);

	if (hotels.isEmpty()) {
		return Collections.emptyList();
	}

	List<Long> hotelIds =
			hotels.stream().map(HotelDTO::getHotelId).toList();

	// 3. Batch availability check
	AvailabilityResponse availability =
			inventoryClient.checkAvailability(
					hotelIds,
					request.getCheckInDate(),
					request.getCheckOutDate()
			);

	// 4. Filter available hotels
	List<String> availableHotelIds =
			availability.getAvailableHotelIds();

	if (availableHotelIds.isEmpty()) {
		return Collections.emptyList();
	}

	// 5. Batch pricing call
	Map<String, BigDecimal> pricing =
			pricingClient.getAvgPrices(
					availableHotelIds,
					request.getCheckInDate(),
					request.getCheckOutDate()
			);

	// 6. Aggregate response
	List<SearchHotelView> results = hotels.stream()
			.filter(h -> availableHotelIds.contains(h.getHotelId()))
			.map(h -> SearchHotelView.from(h, pricing.get(h.getHotelId())))
			.toList();

	// 7. Cache result (short TTL)
	cache.put(request, response);

	return results;
}
```
###### Sample Response

```
[
  {
    "hotelId": 101,
    "name": "Grand Goa Resort",
    "address": "Candolim Beach Road, Goa, India",
    "thumbnailUrl": "https://cdn.example.com/101/thumb.jpg",
    "rating": 4,
    "avgPricePerNight": 4500,
  },
  {
    "hotelId": 102,
    "name": "City Budget Inn",
    "address": "MG Road, Bengaluru, India",
    "thumbnailUrl": "https://cdn.example.com/102/thumb.jpg",
    "rating": 3,
    "avgPricePerNight": 2200,
  }
]
```

**(only for reference)**

Calling "SearchHotelView" a ‚ÄúView‚Äù signals:

> _This is an aggregated, read-only representation assembled for presentation._

---
### Reservation Service

Enable customers to complete bookings by orchestrating the end-to-end reservation workflow.

#### Key API Endpoints

##### <span style="color:purple;">1. POST /reservations/</span>

Use this endpoint to initiate a new reservation.
###### <span style="color:green;">Request Body (Sample)</span>

```
{
	"requestId": "client-uuid-123",¬† ¬† ¬† ¬† // idempotency key (required)
	"customer": {
		¬†"id": "u-123",
		¬†"email": "alice@example.com",
		¬†"phone": "+91-99999-99999"
	},
	"hotelId": "101",
	"items": [
		{ 
			"roomTypeId": "201", 
			"quantity": 2 
		}
	],
	"checkInDate": "2025-10-01",
	"checkOutDate": "2025-10-05"
	"amount": "7200",
	"currency": "INR"
}
```

The `requestId` parameter will act as an idempotency key, allowing system to prevent double booking in case the same user clicks on the `Book Now` button multiple times. The `requestId` usually expires after a certain period of time. 

The `requestId` could be a combination of the items selected or can be generated by a globally unique ID generator. A UUID is commonly used as an idempotency key and it is recommended by many tech companies such as Stripe and Paypal.

If multiple concurrent requests are detected with the same idempotency key, only one request is processed and the others receive a `429 Too Many Requests` status code.

> **NOTE:** Idempotency is key to ensure the at-most-one guarantee.
###### <span style="color:green;">Response Body (Sample)</span>

So at this moment, the backend should return everything the frontend needs to:

- Show the booking summary,
- Redirect the user to the payment page (checkout), and
- Handle countdown/expiry gracefully.

```
{
	"reservationId": "resv_789456123",
	"status": "PENDING",
	"hold": {
		"holdId": "hold_12345",
		"expiresAt": "2025-09-25T14:30:00Z"
	},
	"pricing": {
		"currency": "INR",
		"totalAmount": 18500,
		"breakdown": [
			{
				"roomTypeId": "deluxe_king",
				"nights": 2,
				"pricePerNight": 9250
			}
		]
	},
	"payment": {
	    "paymentSessionId": "pay_sess_987654",
		"redirectUrl": "https://psp.example.com/pay/session/pay_sess_987654"
	}
}
```

The system requires the `reservationId` and `holdId` in the next step (when finalizing/payment) to identify the reservation it's trying to complete and ensure the selected rooms are still reserved.
###### <span style="color:green;">Business Logic</span>

The`ReservationService` intercepts the request, extract all request parameters and delegate it  to the `intiateReservation()` method.

```
public InitiateReservationResponse initiateReservation(
											InitiateReservationRequest req) {

	/*
	 * Step 1: Check if a reservation already exists for the specified requestId
	 * Step 2: Create a new reservation in PENDING state
	 * Step 3: Place a short-lived, idempotent inventory hold
	 * Step 4: Capture a pricing snapshot
	 * Step 5: Create a payment session with the PSP
	 */
}
```

Let's walkthrough each step in detail to understand how the `ReservationService` interacts with `InventoryService` and `PricingService` to serve a reservation initiation request:

<span style="color:brown">Step 1: Check if a reservation already exists for the specified requestId</span>

Each booking attempt includes a client-generated `requestId` (commonly a UUID) to prevent duplicate work when clients retry the same booking request. This allows the reservation flow to enforce idempotency check. 

```
Reservation existing = ReservationRepository.findByRequestId(req.getRequestId());
if(existing != null) return existing;
```

<span style="color:brown">Step 2: Create a new reservation in PENDING state</span>

The system uses this identifier to either create a new reservation with `PENDING` status or return the existing one if the request has already been processed.

```
Reservation reservation = new Reservation(
	req.getRequestId()
	req.getHotelId(),
	req.getRoomTypeId(),
	req.getCheckInDate(),
	req.getCheckOutDate(),
	ReservationStatus.PENDING
);

reservationRepository.save(reservation);
InitiateReservationResponse response = new InitiateReservationResponse(
					reservation.getReservationId(), reservation.getStatus());
```

<span style="color:brown">Step 3: Place a short-lived, idempotent inventory hold</span>

```
¬†InventoryHold hold = inventoryService.placeHold(
	req.getHotelId(), 
	req.getRoomTypeId(),
	req.getCheckInDate(),
	req.getCheckOutDate(),
	reservation.getId()
);

response.setHold(hold);
```

<span style="color:brown">Step 4: Capture a pricing snapshot</span>

```
PriceSnapshot snapshot = pricingService.capturePrice(
	req.getHotelId(), 
	req.getRoomTypeId(),
	req.getCheckInDate(), 
	req.getCheckOutDate()
);

response.setPriceSnapshot(snapshot);
```

<span style="color:brown">Step 5: Create PSP payment session</span>
 
```
PaymentSession session = paymentService.createSession(requestId, 
															amount, currency);
															
response.set(session.redirectUrl());
```
###### <span style="color:green;">Load Estimation</span>

#### <span style="color:purple;">2. POST /reservations/{reservationId}finalize</span>

Use this endpoint to finalize a previously created `PENDING` reservation when the payment provider notifies success.

<span style="color:red;">(discuss about the reason to use webhook)</span>
###### <span style="color:green;">Request Body (Sample)</span>

```
```
###### <span style="color:green;">Response Body (Sample)</span>

```

```
###### <span style="color:green;">Business Logic</span>

The `ReservationService` intercepts the request and delegates it to the `finalizeReservation()` method.

```
public Reservation finalizeReservation(reservationId) {

	/*
	 * Step 1: Load Reservation
	 * Step 2: Verify Payment
	 * Step 3: Release Inventory Lock ????
	 * Step 4: Update Inventory ????
	 * Step 5: Confirm Reservation
	 * Step 6: Send Notification
	*/

}
```

Let's walkthrough each step in detail to understand how the `ReservationService` interacts with the `PaymentService`, `InventoryService` and the `NotificationService` to serve a reservation initiation request:

<span style="color:brown;">Step 1: Load Reservation</span>

```
Reservation reservation = reservationRepository.findById(reservationId);
```

<span style="color:brown;">Step 2: Verify Payment</span>

```
Payment payment = PaymentService.verifyPayment(reservation);
if(!payment.isSuccess()) {
	reservation.setStatus("FAILED");
	reservationRepository.save(reservation);
	return reservation;
}
```

<span style="color:brown;">Step 3: Release Inventory Lock</span>

<span style="color:red;">// NOTE: We release only in failure branches. For success we proceed to confirm/allocate. ???</span>

```
boolean isConfirmed = inventoryService.confirmHold(reservation.getHoldId());
if(!isConfirmed) {
	reservation.setStatus("Pending_Reconcile"); ????
	reservationRepository.save(reservation);
	return reservation;
}
```

<span style="color:brown;">Step 4: Update Inventory</span>

```

```

<span style="color:brown;">Step 5: Confirm Reservation</span>

```
reservation.setStatus("CONFIRMED");
reservationRepository.save(reservation);
```

<span style="color:brown;">Step 6: Send Notification</span>

```
notificationService.sendReservationConfirmation(reservation);
```

#### Design Choice

Webhook + Kafka

```

```


---

To avoid duplicate work when a client retries the same booking request, every reservation flow must include an idempotency mechanism. This is done by requiring a client-generated `requestId` (typically a UUID) for each booking attempt and persisting a reservation request with `PENDING` status. 

If a record already exists, the `ReservationService` simply returns the stored result. If no record exists, the service creates one with status: `PENDING` in an atomic operation to prevent race conditions from simultaneous retries. 

This approach ensures customers are never charged twice for the same booking, and retried requests always return consistent, deterministic results rather than triggering duplicate flows.


Step 3: Revalidates Pricing

Compare the total against the submitted `pricingSnapshot`.




---

**Step 1:** Select inventory records for the given hotelId and roomTypeId for the specified date range: `[checkInDate, checkOutDate)`.

```

```

**Step 2:** For each entry check if the `total_reserved + numberOfRoomsToReserve <= total_inventory`.

```

```

---
### Hotel Service

Enable customers to discover and evaluate hotels by providing access to all the static metadata they need before making a reservation. 

Key endpoints include:

#### <span style="color:purple;">1. GET /hotels?destination=...</span>

Used by `SearchService` to get candidate hotels for a `destination`.

##### <span style="color:green;">Request Body (Sample)</span>

```
It accepts no request body
```
##### <span style="color:green;">Response Body (Sample)</span>

```
[
  {
    "id": 101,
    "name": "Grand Goa Resort",
    "description": "A luxury seaside resort offering modern rooms, infinity 
				    pool, and beach access.",
    "locationId": "GOA",
    "address": "Candolim Beach Road, Goa, India",
    "thumbnailUrl": "https://cdn.example.com/101/thumb.jpg",
    "customerRating": 4.6,
    "starRating": 4,
    "amenities": ["wifi", "pool", "gym", "spa"]
  },
  {
    "id": 102,
    "name": "Westin Resort",
    "description": "Premium 5-star property featuring private beach, fine 
					dining, and wellness spa.",
    "locationId": "GOA",
    "address": "Arpora Beach Road, Goa, India",
    "thumbnailUrl": "https://cdn.example.com/102/thumb.jpg",
    "customerRating": 4.7,
    "starRating": 5,
    "amenities": ["wifi", "pool", "private beach", "restaurant", "bar"]
  }
]
```

##### <span style="color:green;">Business Logic (Pseudo Code)</span>

The `HotelService` will extract the query parameter: `destination` and delegate the request to the `getHotels(destination)` method.

¬†The `gethotel()` method resolves the `destination` to an internal `locationId (for example, mapping "Goa" ‚Üí "GOA")`, queries the `HotelRepository (DB)` to fetch all hotels mapped to that location and return the results as a list of hotel records to the `SearchService`.

```
public List<Hotel> getHotels(String destination) {
	String locationId = LocationRepository.getLocationIdByName(destination);
	return HotelRepository.getHotelsByLocationId(locationId);
}
```

##### <span style="color:green;">Load Estimation</span>

Since this endpoint is primarily invoked by the `SearchService` when handling hotel search requests, its expected load will mirror that of the `GET /search/hotels` endpoint in the `SearchService`.

```
- Average RPS = 250 RPS
- Peak RPS = 1,250 RPS
```

Because the `HotelService` only returns static metadata (which is relatively small and stable), these calls are lightweight and well-suited for caching at multiple layers (e.g., Redis, CDN, or client-side caching).

#### <span style="color:purple;">2. GET /hotel/{id}</span>

Use this endpoint to fetch the details of a specific hotel selected by the customer.

**Request Body (Sample)**

```

```

**Business Logic (Pseudo Code)**

```

```

**Response Body (Sample)**

```

```

**Load Estimation**

---
### Inventory Service

Enable customers to **search** and **reserve** rooms by acting as the authoritative source of truth for per-hotel, per-room-type, per-date availability. 

Key endpoints include:

#### <span style="color:purple;">1. POST /inventory/query</span>

Use this endpoint to fetch room types for the given hotels that are available for the entire range `[checkInDate, checkOutDate)` (i.e., for every night in the range).

> **NOTE:** Availability checks may involve large numbers of `hotelIds`, which can exceed URL length limits if sent via `GET`. By using a `POST` request instead, the `hotelIds` can be passed in the request body, allowing the system to handle arbitrarily large inputs in a clean, reliable, and safe way.

##### <span style="color:green;">Request Body (Sample)</span>

```
{
  "hotelIds": [101, 102, 103],
  "checkInDate": "2025-10-01",
  "checkOutDate": "2025-10-05"
}
```

##### <span style="color:green;">Response Body (Sample)</span>

```
[
    { "hotelId": "101", "roomTypeId": "roomType1" },
    { "hotelId": "101", "roomTypeId": "roomType2" },
    { "hotelId": "102", "roomTypeId": "roomType1" },
    { "hotelId": "102", "roomTypeId": "roomType2" },
    { "hotelId": "103", "roomTypeId": "roomType1" }
]
```

##### <span style="color:green;">Business Logic (Pseudo Code)</span>

<span style="color:red;font-weight:bold;">Q. should we do the night count check in the sql or fetch all inventory records available for the specified hotels in the checkInDate-checkOutDate daterange and then perform groupby and filtering in the application code?</span>

- Minimizes data transfer and memory/CPU in the app (DB is much better at aggregations).
- Uses indexes and query planner; much faster for large hotel/date ranges.
- Keeps logic atomic and simpler in service code (one DB call returns only matching room types).
- App-side grouping is only reasonable for very small datasets or if you need complex non-SQL logic.

When you might do it in application code

- Dataset is tiny (few hotels / short ranges) and you prefer simpler SQL.
- You need complex business logic that‚Äôs hard to express in SQL.
- You already cache full per-date inventory in-app and want to reuse it.

```
SELECT 
	hotel_id, room_type_id
FROM 
	room_type_inventory
WHERE 
	reservation_date >= DATE '2025-10-07'
AND 
	reservation_date < DATE '2025-10-09'
AND 
	total_count > reserved_count
GROUP BY 
	hotel_id, room_type_id
HAVING 
	COUNT(reservation_date) = 2
ORDER BY 
	hotel_id ASC, room_type_id DESC;
```

The `InventoryService` will extract all the query parameters: `hotel_ids`, `check-in-date` and `check-out-date`, and delegate the request to the `getAvailableRoomTypes(hotelIds, checkInDate, checkOutDate)` method.

```
public List<AvailableRoomType> getAvailableRoomTypes(List<String> hotelIds, LocalDate checkInDate, LocalDate checkOutDate) {

	List<AvailableRoomType> availableRoomTypes = new ArrayList<>();

	/*
     * Step 1: Retrieve inventory records for the specified hotels covering the 
		       date range [checkInDate, checkOutDate).
     * Step 2: Filter (hotelId, roomTypeId) pairs to retain only those with 
		       availability for each day in the requested date range.
     */

	return availableRoomTypes;

}
```

Let's walkthrough each step in detail to understand how the `InventoryService` handles an availability request:

###### Step 1: Retrieve inventory records for the specified hotels covering the date range `[checkInDate, checkOutDate)`

```
List<InventoryRecord> records = inventoryRepository.findAvailableRoomTypes(
											hotelIds, checkInDate, checkOutDate);
```

###### Step 2: Filter (hotelId, roomTypeId) pairs to retain only those with availability for each day in the requested date range.

```
// Group records by hotelId and roomTypeId for easy lookup
Map<String, Map<String, List<InventoryRecord>>> grouped = records.stream()
	.collect(Collectors.groupingBy(
		InventoryRecord::getHotelId,
		Collectors.groupingBy(InventoryRecord::getRoomTypeId)));
```

```
long days = ChronoUnit.DAYS.between(checkInDate, checkOutDate);
for(String hotelId : grouped.keySet()) {
	Map<String, List<InventoryRecord>> byRoomType = grouped.get(hotelId);
	for(String roomTypeId : byRoomType.keySet()) {
		List<InventoryRecord> roomTypeRecords = byRoomType.get(roomTypeId);
		if(roomTypeRecords.size() == days) {
			availableRoomTypes.add(new AvailableRoomType(hotelId, roomTypeId));
		}
	}
}
```

##### <span style="color:green;">Load Estimation</span>

```

```

##### Hold request


Optimistic locking is a good option for a hotel reservation system to prevent double booking when multiple users try to book the same room at the same time since the QPS for reservations is not high.


* Create an idempotent hold. Caller should pass a client requestId / holdId (UUID) to make this idempotent.

* Returns 201 when a new hold is created, 200 when an existing ACTIVE hold is found, 409 when insufficient inventory.

<span style="color:red;">If the user clicks¬†Book Now¬†a 15-minute hold is created. If payment is not completed before the TTL, the hold is released and the user is notified and offered options (retry payment, re-check availability, choose alternatives). The backend must safely release inventory and handle any late payment attempts (void / reject).</span>

Common reason for create hold failure:

- **Client/Business failure (inventory says no availability)**: deterministic (e.g., 409 Conflict).
- T**ransient/Infrastructure failure (downstream timeout, 5xx, network)**: retryable.
- **Unexpected error (parsing bug, auth error)**: treat as server error and alert ops.

**Sync retry (fast path):**

- Max attempts:¬†**3**¬†(initial + 2 retries)
- Backoff:¬†**exponential**¬†(e.g., 200ms ‚Üí 500ms ‚Üí 1s)
- Add¬†**full jitter**¬†to avoid thundering herd.
- Total sync budget: ~**2‚Äì3 seconds**¬†(tunable, must be << hold TTL).

> **NOTE:** The locking work happens when the payment page is displayed???

---
### Pricing Service

Allow consumers (`SearchService`, `ReservationService`) to obtain authoritative pricing for hotel room types over a date range. 

Key endpoints include:

#### <span style="color:purple;">1. GET /pricing/query</span>

Used by the `SearchService` to retrieve the **average per-night price** for a given `(hotelId, roomTypeId)` across the specified `[checkInDate, checkOutDate)` date range.

##### <span style="color:green;">Request Body (Sample)</span>

```
It accepts no request body.
```

##### <span style="color:green;">Response Body (Sample)</span>

```
4500.0
```

##### <span style="color:green;">Business Logic (Pseudo Code)</span>

we need to execute the following query:

```
WITH combos(hotel_id, room_type_id) AS (VALUES (1,1), (2,4), (3,7), (3,8))
SELECT c.hotel_id, c.room_type_id, ROUND(AVG(r.rate)) AS avg_rate_per_night
FROM combos c
LEFT JOIN room_type_rate r
	ON c.hotel_id = r.hotel_id
	AND c.room_type_id = r.room_type_id
	AND r.reservation_date >= DATE '2025-10-07'
	AND r.reservation_date < DATE '2025-10-09'
GROUP BY c.hotel_id, c.room_type_id;
```

```
public double getAvgPricePerNight(String hotelId, 
									String roomTypeId, 
									LocalDate checkInDate, 
									LocalDate checkOutDate) {

	List<PricingRecord> priceList = 
		pricingRepository.getPriceByRoomTypeAndDateRange(hotelId, roomTypeId, 
													checkInDate, checkOutDate);

	double totalPrice = priceList.stream()
		.mapToDouble(PricingRecord::getPrice).sum();

	return totalPrice / priceList.size();

}
```

##### <span style="color:green;">Load Estimation</span>

```

```

---
### Payment Service

only talk about the Pay In flow.

> **IMPORTANT:** before persisting payment check if the hold is still valid.

---
### Notification Service

In App and Email confirmation. 


---
### Final API Design 

use microservices architecture

1. search cluster services 

2. booking cluster services

---
### Why do we need a¬†`created_at`¬†attribute?

The¬†`created_at`¬†field records the¬†**exact timestamp when a record was first inserted**¬†into the database.

| Purpose                              | Description                                                                                           |
| ------------------------------------ | ----------------------------------------------------------------------------------------------------- |
| üïí¬†**Auditing & traceability**       | Know¬†_when_¬†something (e.g., booking, user, payment, or hold) was created.                            |
| üìä¬†**Analytics & reporting**         | <span style="color:red;">Measure growth trends ‚Äî bookings/day, users/week, etc.</span>                |
| ‚öôÔ∏è¬†**Debugging & troubleshooting**   | Helps reconstruct events ‚Äî¬†_‚ÄúWhen did this hold start?‚Äù_¬†or¬†_‚ÄúHow long did it last before expiring?‚Äù_ |
| üîÑ¬†**TTL-based cleanup**             | Crucial for background jobs ‚Äî e.g., expire holds after 15 minutes from¬†`created_at`.                  |
| üì¶¬†**Data versioning & replication** | Sync only new or updated rows.                                                                        |
| üîê¬†**Compliance / audit logs**       | Required for regulatory traceability in fintech or booking systems.                                   |

---
### Late payment attempts (very important)

If a payment attempt arrives after expiry:

- Reject with a clear response:
    
    - HTTP¬†`409 Conflict`¬†or¬†`410 Gone`¬†(choose standard; 410 indicates resource expired)
    - Body:¬†`{ code: "HOLD_EXPIRED", message: "Hold expired at 2025-10-25T10:32:00Z" }`

- If payment was already authorized by the gateway but hold expired before capture:
    
    - **Void / cancel**¬†the authorization immediately (call payment gateway void endpoint).
    - Refund if capture already happened (should be avoided by design).

- Record the outcome and notify the user.

---

Let me walk you through the real reason behind returning:

- holdId
- reservationId
- paymentId

in the response of **consumeHold**, even though the caller already knows these values.

Imagine payment-service calls:

```
POST /holds/{holdId}/consume
```

and right after consuming the hold, the network dies / timeout happens.

payment-service does not know if:

- the hold was actually consumed OR
- the request failed before the DB write OR
- something partially happened OR
- retry will double-consume inventory

So it retries.

When inventory-service returns:

```
{
  "holdId": 123,
  "status": "CONSUMED",
  "reservationId": 456,
  "paymentId": "pay_...",
}
```

the payment-service can verify:

- Is this the same payment as I am trying now?
- Does the consumed hold belong to the same reservation?
- Did the previous attempt succeed completely?

This lets the payment-service do clean idempotent logic:

```
if (response.paymentId == myPaymentId && response.reservationId == myReservationId)
    // Safe retry; workflow succeeded previously
else 
    // Something is wrong; possible conflict
```

Without returning these fields, the client would have no way to distinguish:

- valid idempotent success from stale / conflicting / incorrect consumption
  
Huge safety benefit.

---
### Release Hold Functionality

When you ‚Äúrelease a hold‚Äù you‚Äôre basically saying:

> ‚ÄúThis temporary lock on inventory is no longer needed. Put the rooms back into the pool so other customers can book them, and mark this hold as released.‚Äù