
The **Attendance Management System (AMS)** can be designed using a **Layered Architecture**. This approach organizes the system into **distinct layers (Controller–Service–Repository)**, allowing each layer to focus on a single responsibility.

Additionally, we can leverage **Object-Oriented Programming (OOP) principles** to model real-world entities such as **`Teacher`**, **`SchoolClass`**, and **`Student`** as objects, encapsulating both their data and behaviors. This makes the system more intuitive by aligning the software design closely with real-world scenarios.

Let's discuss each component, explaining how the **Layered Architecture** and **OOP design** shape their implementation.

---
### Main Controller Component: `AttendanceManagementSystem`

The `AttendanceManagementSystem` component acts as a **unified interface** for all attendance system operations.

This approach <span style="color:green;font-weight:bold;background:beige;">hides the complexity of underlying components and exposes only high-level methods</span> like `createClass()`, `markAttendance()`, and `generateReport()`. Internally, these methods delegate tasks to the relevant modules (e.g., `ClassService`, `AttendanceService`, or `ReportService`) without revealing their internal workings.

```
/**
 * Main facade class that provides a unified interface for all attendance system  * operations
 */
class AttendanceManagementSystem {
	private final ClassService classService;
	private final AttendanceService attendanceService;
	private final ReportService reportService;
	
	public AttendanceManagementSystem(ClassService classService, 
	                                  AttendanceService attendanceService,
	                                  ReportService reportService) {
		this.classService = classService;
		this.attendanceService = attendanceService;
		this.reportService = reportService;
	}

	// ========== CLASS MANAGEMENT OPERATIONS ==========

	/**
	 * Create a new class with given class name and teacher name
	 */
	public String createClass(String className, String teacherName) {
		return classService.createClass(className, studentName);
	}

	/**
	 * Get all classes in the system 
	 */
	public List<Class> getAllClasses() {
		return classService.getAllClasses();
	}

	/**
	 * Add a student to an existing class
	 */
	public boolean addStudentToClass(String classId, String studentName) {
		return classService.addStudentToClass(classId, studentName);
	}

	/**
	 * Get all student in a class
	 */
	 public List<Student> getAllStudentsInClass(String classId) {
		 return classService.getClass(classId).getStudents();
	 } 

	// ========= ATTENDANCE MANAGEMENT OPERATIONS ==========

	/*
	 * Mark attendance for multiple students in a class for a specific date
	 */
	public boolean markAttendance(String classId, LocalDate date, 
	                    Map<String, AttendanceStatus> studentAttendanceMap) {
		return attendanceService.markAttendance(classId, date,
		                                        studentAttendanceMap);
	}

	// ========== REPORT MANAGEMENT OPERATIONS ==========

	/*
	 * Generate comprehensive class attendance report for a specific month 
	 */
	public ClassAttendanceReport generateClassAttendanceReport(String classId
	                                            int year, int month) {
		return reportService.generateClassAttendanceReport(classId, year, month);
	}

}
```

The design decision to use this class as an interceptor for all incoming requests follows the <span style="color:green;font-weight:bold;background:beige;">Facade Pattern</span>.

Instead of allowing the user interface or external components to directly interact with multiple subsystems such as class creation, student registration, attendance tracking, or report generation, this class provides a **single point of access** to those functionalities.

---
### Service Layer Component: `classService`

The `ClassService` component acts as the **business logic layer** for handling class-related operations.  

It receives requests from the **controller**, applies any business rules, and then delegates persistence tasks to the `ClassRepository`.  Essentially, it acts as the <span style="color:green;font-weight:bold;background:beige;">middleman between the controller and the repository</span>, ensuring the data is correctly processed and ready before being stored or retrieved.

```
/**
 * Service interface for class management operations
 */
interface ClassService {
	String createClass(String className, String teacherName);
	boolean addStudentToClass(int classId, String studentName) throws 
	                                                AttendanceSystemException;
	List<Class> getAllClasses()
}
```

```
/**
 * Implementation of ClassService
 */
public class ClassServiceImpl implements ClassService {
	private final ClassRepository classRepository;
	private int classCounter;

	public ClassServiceImpl(ClassRepository classRepository) {
		this.classRepository = classRepository;
	}

	@Override
	public String createClass(String className, String teacherName) {
		String classId = generateClassId();
		SchoolClass classObj = new SchoolClass(classId, className, teacherName);
		classRepository.save(classObj);
		return classId;
	}

	@Override
	public boolean addStudentToClass(int classId, String rollNumber, 
	                     String studentName) throws AttendanceSystemException {
		Optional<SchoolClass> classOpt = classRepository.findById(classId);
		if(!classOpt.isPresent()) {
			throw new AttendanceSystemException("No class exist with ID: " +
			                                                          classId);
		}
		SchoolClass classObj = classOpt.get();
		Student student = new Student(rollNumber, studentName);
		return classObj.addStudent(student);	
	}

	@Override
	public List<SchoolClass> getAllClasses() {
		return classRepository.findAll();
	}

	// ========= UTILITY METHODS ==========
	private synchronized String generateClassId() {
		return "CLASS_" + String.format("%04d", ++classCounter);
	}
}
```

> **NOTE:** By defining `ClassService` as an interface, higher-level components (like controllers) depend on an abstraction rather than a specific implementation. This makes it easier to change the implementation later without affecting the rest of the system.

---
### Service Layer Component: `attendanceService`

```
/*
 * Service interface for attendance management operations
 */
interface AttendanceService {
	boolean markAttendance(String classId, LocalDate date, 
	                              Map<String, AttendanceStatus> attendanceMap);
}
```

```
/*
 * Implementation of AttendanceService
 */
public class AttendanceServiceImpl implements AttendanceService {

	@Override
	public boolean markAttendanceI(String classId, LocalDate date, 
	                            Map<String, AttendanceStatus> attendanceMap) {
	    
	}
}
```

---