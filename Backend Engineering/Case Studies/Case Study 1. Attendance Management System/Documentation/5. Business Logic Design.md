
The **Business Logic Design** section outlines how the core functional requirements of the Attendance Management System are implemented within the service layer.

Let’s discuss each service in detail, outlining its responsibilities, core methods, and the in-memory data structures it manages.

---
### Create a New Class

```
public String createClass(String className, String teacherName) {  
    
    // Step 1: Check if class with same name already exists  
    boolean exists = classMap.values().stream()  
            .anyMatch(obj->obj.getName().equalsIgnoreCase(req.getClassName()));  
    if(exists) return null;  
  
    // Step 2: Create a new class  
    String classId = generateClassId();  
    Class class = new Class(classId, req.getClassName(), req.getTeacherName());  
    classMap.put(classId, class);  
    return classId;
    
}
```

<span style="color:purple;font-weight:bold;">Class Id Generator</span>

```
private String generateClassId() {  
    return "CLASS_" + String.format("%04d", ++classCounter);  
}
```

---
### Add Student to Class

```
public boolean addStudent(String classId, String enrollmentId, String name) {  
    Class class = classMap.get(classId);  
    // Step 1: Check if the student already exists in the class  
    boolean exists = class.getStudents().containsKey(enrollmentId);  
    if(exists) return false;  
    // Step 2: Create a student and add it to the target class  
    Student student = new Student(enrollmentId, name);  
    class.getStudents().put(enrollmentId, student);  
    return true; 
}
```

---
### Mark Daily Attendance

```
public boolean markAttendance(String classId, LocalDate date, 
											List<AttendanceRecord> records) {  
    Class class = classMap.get(classId);  
    // Step 1: Check if attendance for today's date is already marked  
    boolean exists = class.getAttendanceRecords().containsKey(date);  
    if(exists) return false;  
    // Step 2: Add attendance records for today's date to the target class  
    class.getAttendanceRecords().put(date, records);  
    return true;  
}
```

---
### Generate Class Attendance Report

```
public ClassAttendanceReport generateAttendanceReport(String classId, 
									LocalDate startDate, LocalDate endDate) {  
  
    // Step 1: Filter AttendanceRecords between startDate and endDate  
    ClassEntity classEntity = classMap.get(classId);  
    Map<LocalDate, List<StudentAttendanceRecord>> records = 
									classEntity.getStudentAttendanceRecords();  
    List<StudentAttendanceRecord> filteredRecords = records.entrySet().stream()  
            .filter(entry -> !entry.getKey().isBefore(startDate) && 
									        !entry.getKey().isAfter(endDate))  
            .flatMap(entry -> entry.getValue().stream())  
            .toList();  
  
    // Step 2: Populate each student's StudentAttendanceStats  
    Map<String, StudentAttendanceStats> statsMap = new HashMap<>();  
    for(StudentAttendanceRecord record: filteredRecords) {  
        StudentAttendanceStats stats = statsMap.computeIfAbsent(
		        record.getEnrollmentId(),  
                k -> new StudentAttendanceStats(record.getEnrollmentId(),
								                record.getName()));  
        switch(record.getStatus()) {  
            case "PRESENT": 
	            stats.setTotalPresent(stats.getTotalPresent()+1); 
	            break;  
            case "ABSENT": 
	            stats.setTotalAbsent(stats.getTotalAbsent()+1); 
	            break;  
        }  
    }  
  
    // Step 3: Calculate the attendance percentage for each student  
    int totalDaysRecorded = filteredRecords.size();  
    for(Map.Entry<String, StudentAttendanceStats> entry: statsMap.entrySet()) {  
        double percent = entry.getValue().getTotalPresent() / totalDaysRecorded;
        entry.getValue().setAttendancePercentage(percent);  
    }  
  
    // Step 4: Create the attendance report  
    List<StudentAttendanceStats> attendanceSummary = statsMap.values();  
    return new ClassAttendanceReport(classEntity.getName(), startDate, endDate,
														     attendanceSummary);
}
```

---

Handles all operations related to **class creation**, **retrieval**, and **student allocation**. Acts as the primary service for managing the class-related domain model.


Key services in this design include:
1. **Class Service**: Manages class creation and student assignments.
2. **Attendance Service**: Handles daily attendance tracking
3. **Report Service**: Generates attendance summaries and statistics.

While approaches like synchronized blocks, read-write locks, and immutable objects are possible, **`ConcurrentHashMap`** combined with **fine-grained synchronization on individual `Class` instances** offers the best balance of thread safety and performance. <span style="color:green;font-weight:bold;background:beige;">This ensures multiple threads can operate on different classes concurrently, while updates to the same class remain consistent and safe</span>.


```

```

Retrieve

```
public class ClassService {

    private final Map<String, Class> classMap = new ConcurrentHashMap<>();

    // Create a new class
    public Class createClass(String className, String teacherName) {
	    // add validation logic
        String classId = UUID.randomUUID().toString(); -- change this
        Class newClass = new Class(classId, className, teacherName);
        classMap.put(classId, newClass);
        return newClass;
    }

    // Retrieve all classes
    public List<ClassEntity> getAllClasses() {
        return new ArrayList<>(classMap.values());
    }

    // Retrieve a class by ID
    public ClassEntity getClassById(String classId) {
        ClassEntity classEntity = classMap.get(classId);
        if (classEntity == null) {
            throw new NoSuchElementException("Class not found: " + classId);
        }
        return classEntity;
    }

    // Add a student to a class
    public StudentEntity addStudent(String classId, String studentName, 
                                     int rollNumber) {
        ClassEntity classEntity = getClassById(classId);
        synchronized (classEntity) {
            // Ensure roll number uniqueness within the class
            boolean rollExists = classEntity.getStudents().stream()
                    .anyMatch(s -> s.getRollNumber() == rollNumber);
            if (rollExists) {
                throw new IllegalArgumentException("Roll number already exists");
            }

            String studentId = UUID.randomUUID().toString(); -- change this
            Student newStudent = new Student(studentId, studentName, rollNumber);
            classEntity.getStudents().add(newStudent);
            return newStudent;
        }
    }
}

```

---

The `ClassService` component acts as the **business logic layer** for handling class-related operations.  

It receives requests from the **controller**, applies any business rules, and then delegates persistence tasks to the `ClassRepository`.  Essentially, it acts as the <span style="color:green;font-weight:bold;background:beige;">middleman between the controller and the repository</span>, ensuring the data is correctly processed and ready before being stored or retrieved.

<span style="color:red">write queries this service will be handling</span>

```
/**
 * Service interface for class management operations
 */
interface ClassService {
	String createClass(String className, String teacherName);
	List<Class> getAllClasses()
	boolean addStudentToClass(int classId, String studentName);
	boolean getStudentsInClass(int classId);
}
```

```
/**
 * Implementation of ClassService
 */
public class ClassServiceImpl implements ClassService {
	private final ClassRepository classRepository;
	private int classCounter;

	public ClassServiceImpl(ClassRepository classRepository) {
		this.classRepository = classRepository;
	}

	@Override
	public String createClass(String className, String teacherName) {
		String classId = generateClassId();
		SchoolClass classObj = new SchoolClass(classId, className, teacherName);
		classRepository.save(classObj);
		return classId;
	}

	@Override
	public List<SchoolClass> getAllClasses() {
		return classRepository.findAll();
	}

	@Override
	public boolean addStudentToClass(int classId, String rollNumber, 
	                                                     String studentName) {
		SchoolClass classObj = classRepository.findById(classId);
		Student student = new Student(rollNumber, studentName);
		return classObj.addStudent(student);	
	}

	@Override
	public boolean getStudentsInClass(int classId) {
		SchoolClass classObj = classRepository.findById(classId);
		Student student = new Student(rollNumber, studentName);
		return classObj.addStudent(student);	
	}

	// ========= UTILITY METHODS ==========
	private synchronized String generateClassId() {
		return "CLASS_" + String.format("%04d", ++classCounter);
	}
}
```

---
### Component 2: `AttendanceService`

The `AttendanceService` component acts as the **business logic layer** for handling attendance-related operations.

<span style="color:red">write queries this service will be handling</span>

```
/*
 * Service interface for attendance management operations
 */
interface AttendanceService {
	boolean markAttendance(String classId, LocalDate date, 
	                              Map<String, AttendanceStatus> attendanceMap);
}
```

```
/*
 * Implementation of AttendanceService
 */
public class AttendanceServiceImpl implements AttendanceService {
	private final AttendanceRepository attendanceRepository;

	public AttendanceServiceImpl(AttendanceRepository attendanceRepository) {
		this.attendanceRepository = attendanceRepository;
	}

	@Override
	public boolean markAttendance(String classId, LocalDate date, 
	                            Map<String, AttendanceStatus> attendanceMap) {
		
		// Step 1: Check if attendance is already marked
		if(isAttendanceMarked(classId, date)) {
			throw new IllegalStateException("Attendance Already Marked");
		}

		// Step 2: Create new record for today's attendance
		Map<LocalDate, Map<String, AttendanceStatus>> attendanceRecord = 
															new HashMap<>();
		attendanceRecord.put(date, attendanceMap);

		// Step 3: Save record via repository
		return attendanceRepository.save(classId, attendanceRecord);
		
	}

	// ========== UTILITY METHODS ==========
	private boolean isAttendanceMarked(String classId, LocalDate date) {

		// Step 1: Fetch existing record for the class
		Map<LocalDate, Map<String, AttendanceStatus>> classSttendanceRecords = 
		                           attendanceRepository.findByClassId(classId);
		
		// Step 2: Check if date already exists in the record
		return classAttendanceRecords !=null && 
		       classAttendanceRecords.containsKey(date);
		
	}

}
```

---
### Component 3: `ReportService`

<span style="color:red">write queries this service will be handling</span>

```
/*
 * Service interface for generating attendance report
 */
interface ReportService {
	ClassAttendanceReport generateClassAttendanceReport(String classId, 
	                                                       int year, int month);
}
```

```
/*
 * Implementation of ReportService
 */
public class ReportServiceImpl implements ReportService {

	@Override
	public ClassAttendanceReport generateClassAttendanceReport(String classId,
														int year, int month) {

		List<StudentAttendanceRecord> classAttendanceRecords = 
		            AttendanceRepository.findByClassAndMonth(classId);

		if(classAttendanceRecords == null) {
			throw new Exception()
		}

	}

}
```

---
