
The **service layer is the implementation of the business logic design** in code. It’s where the application’s brain lives, turning business requirements into actionable logic while shielding other layers from complexity.

Let’s discuss the key components of the service layer: `ClassService`, `AttendanceService`, and `ReportService**`**, and examine how each implements the system’s core workflows while following object-oriented and solid design principle foundations.

> **NOTE:** By defining `ClassService`, `AttendanceService`, and `ReportService` as an interface, higher-level components (like controllers) depend on an abstraction rather than a specific implementation. This makes it easier to change the implementation later without affecting the rest of the system.
 
---
### Class Service

The `ClassService` component acts as the **business logic layer** for handling class-related operations.  

It receives requests from the **controller**, applies any business rules, and then delegates persistence tasks to the `ClassRepository`.  Essentially, it acts as the <span style="color:green;font-weight:bold;background:beige;">middleman between the controller and the repository</span>, ensuring the data is correctly processed and ready before being stored or retrieved.

<span style="color:red">write queries this service will be handling</span>

```
/**
 * Service interface for class management operations
 */
interface ClassService {
	String createClass(String className, String teacherName);
	List<Class> getAllClasses()
	boolean addStudentToClass(int classId, String studentName);
	boolean getStudentsInClass(int classId);
}
```

```
/**
 * Implementation of ClassService
 */
public class ClassServiceImpl implements ClassService {
	private final ClassRepository classRepository;
	private int classCounter;

	public ClassServiceImpl(ClassRepository classRepository) {
		this.classRepository = classRepository;
	}

	@Override
	public String createClass(String className, String teacherName) {
		String classId = generateClassId();
		SchoolClass classObj = new SchoolClass(classId, className, teacherName);
		classRepository.save(classObj);
		return classId;
	}

	@Override
	public List<SchoolClass> getAllClasses() {
		return classRepository.findAll();
	}

	@Override
	public boolean addStudentToClass(int classId, String rollNumber, 
	                                                     String studentName) {
		SchoolClass classObj = classRepository.findById(classId);
		Student student = new Student(rollNumber, studentName);
		return classObj.addStudent(student);	
	}

	@Override
	public boolean getStudentsInClass(int classId) {
		SchoolClass classObj = classRepository.findById(classId);
		Student student = new Student(rollNumber, studentName);
		return classObj.addStudent(student);	
	}

	// ========= UTILITY METHODS ==========
	private synchronized String generateClassId() {
		return "CLASS_" + String.format("%04d", ++classCounter);
	}
}
```

---
### Component 2: `AttendanceService`

The `AttendanceService` component acts as the **business logic layer** for handling attendance-related operations.

<span style="color:red">write queries this service will be handling</span>

```
/*
 * Service interface for attendance management operations
 */
interface AttendanceService {
	boolean markAttendance(String classId, LocalDate date, 
	                              Map<String, AttendanceStatus> attendanceMap);
}
```

```
/*
 * Implementation of AttendanceService
 */
public class AttendanceServiceImpl implements AttendanceService {
	private final AttendanceRepository attendanceRepository;

	public AttendanceServiceImpl(AttendanceRepository attendanceRepository) {
		this.attendanceRepository = attendanceRepository;
	}

	@Override
	public boolean markAttendance(String classId, LocalDate date, 
	                            Map<String, AttendanceStatus> attendanceMap) {
		
		// Step 1: Check if attendance is already marked
		if(isAttendanceMarked(classId, date)) {
			throw new IllegalStateException("Attendance Already Marked");
		}

		// Step 2: Create new record for today's attendance
		Map<LocalDate, Map<String, AttendanceStatus>> attendanceRecord = 
															new HashMap<>();
		attendanceRecord.put(date, attendanceMap);

		// Step 3: Save record via repository
		return attendanceRepository.save(classId, attendanceRecord);
		
	}

	// ========== UTILITY METHODS ==========
	private boolean isAttendanceMarked(String classId, LocalDate date) {

		// Step 1: Fetch existing record for the class
		Map<LocalDate, Map<String, AttendanceStatus>> classSttendanceRecords = 
		                           attendanceRepository.findByClassId(classId);
		
		// Step 2: Check if date already exists in the record
		return classAttendanceRecords !=null && 
		       classAttendanceRecords.containsKey(date);
		
	}

}
```

---
### Component 3: `ReportService`

<span style="color:red">write queries this service will be handling</span>

```
/*
 * Service interface for generating attendance report
 */
interface ReportService {
	ClassAttendanceReport generateClassAttendanceReport(String classId, 
	                                                       int year, int month);
}
```

```
/*
 * Implementation of ReportService
 */
public class ReportServiceImpl implements ReportService {

	@Override
	public ClassAttendanceReport generateClassAttendanceReport(String classId,
														int year, int month) {

		List<StudentAttendanceRecord> classAttendanceRecords = 
		            AttendanceRepository.findByClassAndMonth(classId);

		if(classAttendanceRecords == null) {
			throw new Exception()
		}

	}

}
```

---
