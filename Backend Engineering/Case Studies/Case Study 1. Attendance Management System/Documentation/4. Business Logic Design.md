
The **Business Logic Design** section outlines how the core functional requirements of the Attendance Management System are implemented within the service layer.

Let’s discuss each service in detail, outlining its responsibilities, core methods, and the in-memory data structures it manages.
 
---
### In-Memory Storage

Handles all operations related to **class creation**, **retrieval**, and **student allocation**. Acts as the primary service for managing the class-related domain model.

We can use a **`HashMap`** to provide an in-memory solution for storing classes, as it offers efficient key-based access and retrieval, making it well-suited for quick lookups. However, in a multi-user environment where <span style="color:green;font-weight:bold;background:beige;">multiple teachers may simultaneously add classes</span>, concurrency issues like data inconsistency, lost updates, and race conditions can arise if a regular **`HashMap`** is used.

To handle this, we can use a **`ConcurrentHashMap`** to store the classes.

```
private final Map<String, Class> classMap = new ConcurrentHashMap<>();
```

The `classMap` maps each **`classId`** (String) to its corresponding **`Class`** entity, forming the backbone of our in-memory class registry.

---

Key services in this design include:
1. **Class Service**: Manages class creation and student assignments.
2. **Attendance Service**: Handles daily attendance tracking
3. **Report Service**: Generates attendance summaries and statistics.

While approaches like synchronized blocks, read-write locks, and immutable objects are possible, **`ConcurrentHashMap`** combined with **fine-grained synchronization on individual `Class` instances** offers the best balance of thread safety and performance. <span style="color:green;font-weight:bold;background:beige;">This ensures multiple threads can operate on different classes concurrently, while updates to the same class remain consistent and safe</span>.

In-Memory Storage

Create a New Class

```

```

Retrieve

```
public class ClassService {

    private final Map<String, Class> classMap = new ConcurrentHashMap<>();

    // Create a new class
    public Class createClass(String className, String teacherName) {
	    // add validation logic
        String classId = UUID.randomUUID().toString(); -- change this
        Class newClass = new Class(classId, className, teacherName);
        classMap.put(classId, newClass);
        return newClass;
    }

    // Retrieve all classes
    public List<ClassEntity> getAllClasses() {
        return new ArrayList<>(classMap.values());
    }

    // Retrieve a class by ID
    public ClassEntity getClassById(String classId) {
        ClassEntity classEntity = classMap.get(classId);
        if (classEntity == null) {
            throw new NoSuchElementException("Class not found: " + classId);
        }
        return classEntity;
    }

    // Add a student to a class
    public StudentEntity addStudent(String classId, String studentName, 
                                     int rollNumber) {
        ClassEntity classEntity = getClassById(classId);
        synchronized (classEntity) {
            // Ensure roll number uniqueness within the class
            boolean rollExists = classEntity.getStudents().stream()
                    .anyMatch(s -> s.getRollNumber() == rollNumber);
            if (rollExists) {
                throw new IllegalArgumentException("Roll number already exists");
            }

            String studentId = UUID.randomUUID().toString(); -- change this
            Student newStudent = new Student(studentId, studentName, rollNumber);
            classEntity.getStudents().add(newStudent);
            return newStudent;
        }
    }
}

```

---

The `ClassService` component acts as the **business logic layer** for handling class-related operations.  

It receives requests from the **controller**, applies any business rules, and then delegates persistence tasks to the `ClassRepository`.  Essentially, it acts as the <span style="color:green;font-weight:bold;background:beige;">middleman between the controller and the repository</span>, ensuring the data is correctly processed and ready before being stored or retrieved.

<span style="color:red">write queries this service will be handling</span>

```
/**
 * Service interface for class management operations
 */
interface ClassService {
	String createClass(String className, String teacherName);
	List<Class> getAllClasses()
	boolean addStudentToClass(int classId, String studentName);
	boolean getStudentsInClass(int classId);
}
```

```
/**
 * Implementation of ClassService
 */
public class ClassServiceImpl implements ClassService {
	private final ClassRepository classRepository;
	private int classCounter;

	public ClassServiceImpl(ClassRepository classRepository) {
		this.classRepository = classRepository;
	}

	@Override
	public String createClass(String className, String teacherName) {
		String classId = generateClassId();
		SchoolClass classObj = new SchoolClass(classId, className, teacherName);
		classRepository.save(classObj);
		return classId;
	}

	@Override
	public List<SchoolClass> getAllClasses() {
		return classRepository.findAll();
	}

	@Override
	public boolean addStudentToClass(int classId, String rollNumber, 
	                                                     String studentName) {
		SchoolClass classObj = classRepository.findById(classId);
		Student student = new Student(rollNumber, studentName);
		return classObj.addStudent(student);	
	}

	@Override
	public boolean getStudentsInClass(int classId) {
		SchoolClass classObj = classRepository.findById(classId);
		Student student = new Student(rollNumber, studentName);
		return classObj.addStudent(student);	
	}

	// ========= UTILITY METHODS ==========
	private synchronized String generateClassId() {
		return "CLASS_" + String.format("%04d", ++classCounter);
	}
}
```

---
### Component 2: `AttendanceService`

The `AttendanceService` component acts as the **business logic layer** for handling attendance-related operations.

<span style="color:red">write queries this service will be handling</span>

```
/*
 * Service interface for attendance management operations
 */
interface AttendanceService {
	boolean markAttendance(String classId, LocalDate date, 
	                              Map<String, AttendanceStatus> attendanceMap);
}
```

```
/*
 * Implementation of AttendanceService
 */
public class AttendanceServiceImpl implements AttendanceService {
	private final AttendanceRepository attendanceRepository;

	public AttendanceServiceImpl(AttendanceRepository attendanceRepository) {
		this.attendanceRepository = attendanceRepository;
	}

	@Override
	public boolean markAttendance(String classId, LocalDate date, 
	                            Map<String, AttendanceStatus> attendanceMap) {
		
		// Step 1: Check if attendance is already marked
		if(isAttendanceMarked(classId, date)) {
			throw new IllegalStateException("Attendance Already Marked");
		}

		// Step 2: Create new record for today's attendance
		Map<LocalDate, Map<String, AttendanceStatus>> attendanceRecord = 
															new HashMap<>();
		attendanceRecord.put(date, attendanceMap);

		// Step 3: Save record via repository
		return attendanceRepository.save(classId, attendanceRecord);
		
	}

	// ========== UTILITY METHODS ==========
	private boolean isAttendanceMarked(String classId, LocalDate date) {

		// Step 1: Fetch existing record for the class
		Map<LocalDate, Map<String, AttendanceStatus>> classSttendanceRecords = 
		                           attendanceRepository.findByClassId(classId);
		
		// Step 2: Check if date already exists in the record
		return classAttendanceRecords !=null && 
		       classAttendanceRecords.containsKey(date);
		
	}

}
```

---
### Component 3: `ReportService`

<span style="color:red">write queries this service will be handling</span>

```
/*
 * Service interface for generating attendance report
 */
interface ReportService {
	ClassAttendanceReport generateClassAttendanceReport(String classId, 
	                                                       int year, int month);
}
```

```
/*
 * Implementation of ReportService
 */
public class ReportServiceImpl implements ReportService {

	@Override
	public ClassAttendanceReport generateClassAttendanceReport(String classId,
														int year, int month) {

		List<StudentAttendanceRecord> classAttendanceRecords = 
		            AttendanceRepository.findByClassAndMonth(classId);

		if(classAttendanceRecords == null) {
			throw new Exception()
		}

	}

}
```

---
