
The **Hotel Reservation System** can be organized into the following services, each focused on a core function of the platform: 

1. **User Service**:

2. **Hotel Service**: Act as the source of truth for all static hotel and room type metadata.

3. **Inventory Service**: Act as the single source of truth for real-time room availability and allocation.

4. **Pricing Service**: Act as the authoritative source for room pricing, calculating per-night rates and total stay costs to ensure consistency between search results and final booking.

5. **Search Service**: Act as the central orchestrator for hotel discovery by combining hotel metadata, real-time room availability, and latest pricing.

6. **Reservation Service**: Act as the orchestrator for bookings, coordinating availability checks, price validations, payment processing, and inventory updates to safely create and manage reservations.

7. **Payment Service**:

8. **Notification Service**: 

Let's discuss the **API design** of the core services in detail, covering key aspects such as main endpoints, request and response structures, underlying business logic, and estimated load expectations.

---
### User Service

<span style="color:purple;font-weight:bold">Load Estimation</span>

```
- Assumption: Daily Active Users (DAU) = 5 Million
- Assumption: 20% of DAU log in per day

- Total Requests per Day = 5M * 20% = 1M
- Average RPS = 1,000,000 / (24 * 60 * 60) ≈ 10 RPS

- Assumption: Peak Load Factor = 5x
- Peak RPS = 10 * 5 ≈ 50 RPS
```

> Design Choice: Keep IAM API (for sign in and api requests) separate from User API

---
### Search Service

Enable customers to find hotels by providing a **destination** and **travel dates**. 

#### Key API Endpoints

##### <span style="color:purple">1. GET /search/hotels?destination=...&check-in-date=...&check-out-date=...</span>

Use this endpoint to fetch the list of hotels that have at least one bookable room for the selected query parameters: `destination`, `check-in-date`, and `check-out-date`.
###### <span style="color:green;">Request Body (Sample)</span>

```
It accepts no request body.
```
###### <span style="color:green;">Response Body (Sample)</span>

```
[
  {
    "hotelId": 101,
    "hotelName": "Grand Goa Resort",
    "address": "Candolim Beach Road, Goa, India",
    "thumbnailUrl": "https://cdn.example.com/101/thumb.jpg",
    "starRating": 4,
    "lowestPricePerNight": 4500.0,
  },
  {
    "hotelId": 102,
    "hotelName": "City Budget Inn",
    "address": "MG Road, Bengaluru, India",
    "thumbnailUrl": "https://cdn.example.com/102/thumb.jpg",
    "starRating": 3,
    "lowestPricePerNight": 2200.0,
  }
]
```
###### <span style="color:green;">Business Logic (Pseudo Code)</span>

The `SearchService` will extract all the query parameters: `destination`, `check-in-date` and `check-out-date`, and delegate the request to the `search(destination, checkInDate, checkOutDate)` method.

```
public List<AvailableHotelSummary> search(String destination, 
											LocalDate checkInDate, 
											LocalDate checkOutDate) {

        List<AvailableHotelSummary> availableHotelSummaries = new ArrayList<>();
        
        /*
         * Step 1: Fetch hotel metadata for the given destination
         * Step 2: Query room availability across travel dates
         * Step 3: Calculate lowest average per-night price for each hotel   
         */
         
        return availableHotelSummaries;
        
    }
```

Let's walkthrough each step in detail to understand how the `SearchService` interacts with `HotelService`, `InventoryService` and `PricingService` to serve a search request:

<span style="color:brown">Step 1: Fetch hotel metadata for the given destination</span>

Call the `HotelService` to retrieve a list of hotels matching the `destination`. This provides static attributes like hotel `name`, `address`, `thumbnailUrl`, `starRating` etc.

```
List<Hotel> hotels = hotelServiceClient.getHotelsByDestination(destination);
```

<span style="color:brown">Step 2: Query room availability across travel dates</span>

Call the `InventoryService` to find which room types are available across the entire date range `[checkInDate, checkOutDate)`. This ensures we only consider hotels that can actually accommodate the request.

```
List<String> hotelIds = hotels.stream().map(Hotel::getId).toList();
List<AvailableRoomType> availableRoomTypes = inventoryServiceClient
            .getAvailableRoomTypes(hotelIds, checkInDate, checkOutDate));
```

<span style="color:brown">Step 3: Calculate lowest average per-night price for each hotel and build response</span>

Call the `PricingService` for each available `{hotelId, roomTypeId}` pair to fetch prices, compute the average per-night price across the stay, select the lowest among them, and assemble an `AvailableHotelSummary` with the hotel’s static details and the chosen price.

```
Map<String, Hotel> hotelById = hotels.stream()
	.collect(Collectors.toMap(Hotel::getId, hotelObj -> hotelObj));

Map<String, List<AvailableRoomType>> grouped = availableRoomTypes.stream()
    .collect(Collectors.groupingBy(AvailableRoomType::getHotelId));

 for(String hotelId : grouped.keySet()) {
    Hotel hotel = hotelById.get(hotelId);
    AvailableHotelSummary hotelSummary = new AvailableHotelSummary(hotel);
    
    for(AvailableRoomType availableRoomType : grouped.get(hotelId) ) {
        double price = pricingServiceClient.getAvgPricePerNight(
	        new PricingQueryRequest(
		        availableRoomType.getHotelId(),
		        availableRoomType.getRoomTypeId(), 
		        checkInDate, 
		        checkOutDate)
		);
	     
        hotelSummary.setLowestPrice(
	        Math.min(hotelSummary.getLowestPrice(), price));
    }
    
    availableHotelSummaries.add(hotelSummary);
}
```

#### Load Estimation

```
- Assumption: Daily Active Users (DAU) = 5 Million
- Assumption: Average Search Requests per User per Day = 5

- Total Requests per Day = 5M * 5 = 25M
- Average RPS = 25,000,000 / (86,400) ≈ 250 RPS

- Assumption: Peak Load Factor = 5x
- Peak RPS = 250 * 5 ≈ 1,250 RPS
```

---
### Reservation Service

Enable customers to complete bookings by orchestrating the end-to-end reservation workflow.

#### Key API Endpoints

##### <span style="color:purple;">1. POST /reservations/initiate</span>

Use this endpoint to initiate a new reservation.
###### <span style="color:green;">Request Body (Sample)</span>

```
{
	"requestId": "client-uuid-123",        // idempotency key (required)
	"customer": {
		 "id": "u-123",
		 "email": "alice@example.com",
		 "phone": "+91-99999-99999"
	},
	"hotelId": "101",
	"items": [
		{ 
			"roomTypeId": "201", 
			"quantity": 2 
		}
	],
	"checkInDate": "2025-10-01",
	"checkOutDate": "2025-10-05"
	"amount": "7200",
	"currency": "INR"
}
```

The `requestId` parameter will act as an idempotency key, allowing system to prevent double booking in case the same user clicks on the `Book Now` button multiple times. The `requestId` usually expires after a certain period of time. 

The `requestId` could be a combination of the items selected or can be generated by a globally unique ID generator. A UUID is commonly used as an idempotency key and it is recommended by many tech companies such as Stripe and Paypal.

If multiple concurrent requests are detected with the same idempotency key, only one request is processed and the others receive a `429 Too Many Requests` status code.

> **NOTE:** Idempotency is key to ensure the at-most-one guarantee.
###### <span style="color:green;">Response Body (Sample)</span>

```
{
	"reservationId": "resv_789456123",
	"status": "PENDING",
	"hold": {
		"holdId": "hold_12345",
		"expiresAt": "2025-09-25T14:30:00Z"
	},
	"pricing": {
		"currency": "INR",
		"totalAmount": 18500,
		"breakdown": [
			{
				"roomTypeId": "deluxe_king",
				"nights": 2,
				"pricePerNight": 9250
			}
		]
	},
	"payment": {
	    "paymentSessionId": "pay_sess_987654",
		"redirectUrl": "https://psp.example.com/pay/session/pay_sess_987654"
	}
}
```

The system requires the `reservationId` and `holdId` in the next step (when finalizing/payment) to identify the reservation it's trying to complete and ensure the selected rooms are still reserved.
###### <span style="color:green;">Business Logic</span>

The`ReservationService` intercepts the request, extract all request parameters and delegate it  to the `intiateReservation()` method.

```
public InitiateReservationResponse initiateReservation(
											InitiateReservationRequest req) {

	/*
	 * Step 1: Check if a reservation already exists for the specified requestId
	 * Step 2: Create a new reservation in PENDING state
	 * Step 3: Place a short-lived, idempotent inventory hold
	 * Step 4: Capture a pricing snapshot
	 * Step 5: Create a payment session with the PSP
	 */
}
```

Let's walkthrough each step in detail to understand how the `ReservationService` interacts with `InventoryService` and `PricingService` to serve a reservation initiation request:

<span style="color:brown">Step 1: Check if a reservation already exists for the specified requestId</span>

Each booking attempt includes a client-generated `requestId` (commonly a UUID) to prevent duplicate work when clients retry the same booking request. This allows the reservation flow to enforce idempotency check. 

```
Reservation existing = ReservationRepository.findByRequestId(req.getRequestId());
if(existing != null) return existing;
```

<span style="color:brown">Step 2: Create a new reservation in PENDING state</span>

The system uses this identifier to either create a new reservation with `PENDING` status or return the existing one if the request has already been processed.

```
Reservation reservation = new Reservation(
	req.getRequestId()
	req.getHotelId(),
	req.getRoomTypeId(),
	req.getCheckInDate(),
	req.getCheckOutDate(),
	ReservationStatus.PENDING
);

reservationRepository.save(reservation);
InitiateReservationResponse response = new InitiateReservationResponse(
					reservation.getReservationId(), reservation.getStatus());
```

<span style="color:brown">Step 3: Place a short-lived, idempotent inventory hold</span>

```
 InventoryHold hold = inventoryService.placeHold(
	req.getHotelId(), 
	req.getRoomTypeId(),
	req.getCheckInDate(),
	req.getCheckOutDate(),
	reservation.getId()
);

response.setHold(hold);
```

<span style="color:brown">Step 4: Capture a pricing snapshot</span>

```
PriceSnapshot snapshot = pricingService.capturePrice(
	req.getHotelId(), 
	req.getRoomTypeId(),
	req.getCheckInDate(), 
	req.getCheckOutDate()
);

response.setPriceSnapshot(snapshot);
```

<span style="color:brown">Step 5: Create PSP payment session</span>
 
```
PaymentSession session = paymentService.createSession(requestId, 
															amount, currency);
															
response.set(session.redirectUrl());
```
#### <span style="color:purple;">2. POST /reservations/finalize</span>

Use this endpoint to finalize a pending reservation when the customer proceeds to payment (clicks `Pay Now`).

3. User pays at PSP; PSP webhook → server finalize logic: verify payment → Inventory.confirm(holdId) → set CONFIRMED → notify.
###### <span style="color:green;">Request Body (Sample)</span>

```

```
###### <span style="color:green;">Response Body (Sample)</span>

```

```
###### <span style="color:green;">Business Logic</span>

```

```

#### Load Estimation

```
- Assumption: 2% of users make a booking per day
- Assumption: Average Booking Requests per User per Day = 1

- Total Requests per Day = 5M * 2% = 100,000
- Average RPS = 100,000 / (24 * 60 * 60) ≈ 1 RPS

- Assumption: Peak Load Factor = 5x
- Peak RPS = 1 * 5 = 5 RPS
```

---

To avoid duplicate work when a client retries the same booking request, every reservation flow must include an idempotency mechanism. This is done by requiring a client-generated `requestId` (typically a UUID) for each booking attempt and persisting a reservation request with `PENDING` status. 

If a record already exists, the `ReservationService` simply returns the stored result. If no record exists, the service creates one with status: `PENDING` in an atomic operation to prevent race conditions from simultaneous retries. 

This approach ensures customers are never charged twice for the same booking, and retried requests always return consistent, deterministic results rather than triggering duplicate flows.


Step 3: Revalidates Pricing

Compare the total against the submitted `pricingSnapshot`.




---

**Step 1:** Select inventory records for the given hotelId and roomTypeId for the specified date range: `[checkInDate, checkOutDate)`.

```

```

**Step 2:** For each entry check if the `total_reserved + numberOfRoomsToReserve <= total_inventory`.

```

```

---
### Hotel Service

Enable customers to discover and evaluate hotels by providing access to all the static metadata they need before making a reservation. 

Key endpoints include:

#### <span style="color:purple;">1. GET /hotels?destination=...</span>

Used by `SearchService` to get candidate hotels for a `destination`.

##### <span style="color:green;">Request Body (Sample)</span>

```
It accepts no request body
```
##### <span style="color:green;">Response Body (Sample)</span>

```
[
  {
    "id": 101,
    "name": "Grand Goa Resort",
    "description": "A luxury seaside resort offering modern rooms, infinity 
				    pool, and beach access.",
    "locationId": "GOA",
    "address": "Candolim Beach Road, Goa, India",
    "thumbnailUrl": "https://cdn.example.com/101/thumb.jpg",
    "customerRating": 4.6,
    "starRating": 4,
    "amenities": ["wifi", "pool", "gym", "spa"]
  },
  {
    "id": 102,
    "name": "Westin Resort",
    "description": "Premium 5-star property featuring private beach, fine 
					dining, and wellness spa.",
    "locationId": "GOA",
    "address": "Arpora Beach Road, Goa, India",
    "thumbnailUrl": "https://cdn.example.com/102/thumb.jpg",
    "customerRating": 4.7,
    "starRating": 5,
    "amenities": ["wifi", "pool", "private beach", "restaurant", "bar"]
  }
]
```

##### <span style="color:green;">Business Logic (Pseudo Code)</span>

The `HotelService` will extract the query parameter: `destination` and delegate the request to the `getHotels(destination)` method.

 The `gethotel()` method resolves the `destination` to an internal `locationId (for example, mapping "Goa" → "GOA")`, queries the `HotelRepository (DB)` to fetch all hotels mapped to that location and return the results as a list of hotel records to the `SearchService`.

```
public List<Hotel> getHotels(String destination) {
	String locationId = LocationRepository.getLocationIdByName(destination);
	return HotelRepository.getHotelsByLocationId(locationId);
}
```

##### <span style="color:green;">Load Estimation</span>

Since this endpoint is primarily invoked by the `SearchService` when handling hotel search requests, its expected load will mirror that of the `GET /search/hotels` endpoint in the `SearchService`.

```
- Average RPS = 250 RPS
- Peak RPS = 1,250 RPS
```

Because the `HotelService` only returns static metadata (which is relatively small and stable), these calls are lightweight and well-suited for caching at multiple layers (e.g., Redis, CDN, or client-side caching).

#### <span style="color:purple;">2. GET /hotel/{id}</span>

Use this endpoint to fetch the details of a specific hotel selected by the customer.

**Request Body (Sample)**

```

```

**Business Logic (Pseudo Code)**

```

```

**Response Body (Sample)**

```

```

**Load Estimation**

```
- Assumption: 50% of users view details after search
- Assumption: Average View Details Requests per User per Day = 2

- Total Requests per Day = 5M * 50% * 2 = 5,000,000
- Average RPS = 5,000,000 / (86,400) ≈ 50 RPS

- Assumption: Peak Load Factor = 5x
- Peak RPS = 50 * 5 ≈ 250 RPS
```

---
### Inventory Service

Enable customers to **search** and **reserve** rooms by acting as the authoritative source of truth for per-hotel, per-room-type, per-date availability. 

Key endpoints include:

#### <span style="color:purple;">1. POST /inventory/query</span>

Use this endpoint to fetch list of room types for selected hotels that have continuous availability across the requested date range.

> **NOTE:** Availability checks may involve large numbers of `hotelIds`, which can exceed URL length limits if sent via `GET`. By using a `POST` request instead, the `hotelIds` can be passed in the request body, allowing the system to handle arbitrarily large inputs in a clean, reliable, and safe way.

##### <span style="color:green;">Request Body (Sample)</span>

```
{
  "hotelIds": [101, 102, 103],
  "checkInDate": "2025-10-01",
  "checkOutDate": "2025-10-05"
}
```

##### <span style="color:green;">Response Body (Sample)</span>

```
[
    { "hotelId": "101", "roomTypeId": "roomType1" },
    { "hotelId": "101", "roomTypeId": "roomType2" },
    { "hotelId": "102", "roomTypeId": "roomType1" },
    { "hotelId": "102", "roomTypeId": "roomType2" },
    { "hotelId": "103", "roomTypeId": "roomType1" }
]
```

##### <span style="color:green;">Business Logic (Pseudo Code)</span>

The `InventoryService` will extract all the query parameters: `hotel_ids`, `check-in-date` and `check-out-date`, and delegate the request to the `getAvailableRoomTypes(hotelIds, checkInDate, checkOutDate)` method.

```
public List<AvailableRoomType> getAvailableRoomTypes(List<String> hotelIds, LocalDate checkInDate, LocalDate checkOutDate) {

	List<AvailableRoomType> availableRoomTypes = new ArrayList<>();

	/*
     * Step 1: Retrieve inventory records for the specified hotels covering the 
		       date range [checkInDate, checkOutDate).
     * Step 2: Filter (hotelId, roomTypeId) pairs to retain only those with 
		       availability for each day in the requested date range.
     */

	return availableRoomTypes;

}
```

Let's walkthrough each step in detail to understand how the `InventoryService` handles an availability request:

###### Step 1: Retrieve inventory records for the specified hotels covering the date range `[checkInDate, checkOutDate)`

```
List<InventoryRecord> records = inventoryRepository.findAvailableRoomTypes(
											hotelIds, checkInDate, checkOutDate);
```

###### Step 2: Filter (hotelId, roomTypeId) pairs to retain only those with availability for each day in the requested date range.

```
// Group records by hotelId and roomTypeId for easy lookup
Map<String, Map<String, List<InventoryRecord>>> grouped = records.stream()
	.collect(Collectors.groupingBy(
		InventoryRecord::getHotelId,
		Collectors.groupingBy(InventoryRecord::getRoomTypeId)));
```

```
long days = ChronoUnit.DAYS.between(checkInDate, checkOutDate);
for(String hotelId : grouped.keySet()) {
	Map<String, List<InventoryRecord>> byRoomType = grouped.get(hotelId);
	for(String roomTypeId : byRoomType.keySet()) {
		List<InventoryRecord> roomTypeRecords = byRoomType.get(roomTypeId);
		if(roomTypeRecords.size() == days) {
			availableRoomTypes.add(new AvailableRoomType(hotelId, roomTypeId));
		}
	}
}
```

##### <span style="color:green;">Load Estimation</span>

```

```

2. Hold request

Optimistic locking is a good option for a hotel reservation system to prevent double booking when multiple users try to book the same room at the same time since the QPS for reservations is not high.

> NOTE: The locking work happens when the payment page is displayed???


---
### Pricing Service

Allow consumers (`SearchService`, `ReservationService`) to obtain authoritative pricing for hotel room types over a date range. 

Key endpoints include:

#### <span style="color:purple;">1. GET /pricing/query</span>

Used by the `SearchService` to retrieve the **average per-night price** for a given `(hotelId, roomTypeId)` across the specified `[checkInDate, checkOutDate)` date range.

##### <span style="color:green;">Request Body (Sample)</span>

```
It accepts no request body.
```

##### <span style="color:green;">Response Body (Sample)</span>

```
4500.0
```

##### <span style="color:green;">Business Logic (Pseudo Code)</span>

```
public double getAvgPricePerNight(String hotelId, 
									String roomTypeId, 
									LocalDate checkInDate, 
									LocalDate checkOutDate) {

	List<PricingRecord> priceList = 
		pricingRepository.getPriceByRoomTypeAndDateRange(hotelId, roomTypeId, 
													checkInDate, checkOutDate);

	double totalPrice = priceList.stream()
		.mapToDouble(PricingRecord::getPrice).sum();

	return totalPrice / priceList.size();

}
```

##### <span style="color:green;">Load Estimation</span>

```

```

---
### Payment Service

only talk about the Pay In flow.

---
### Notification Service

In App and Email confirmation. 


---
