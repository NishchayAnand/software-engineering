
The **Hotel Reservation System** can be organized into the following services, each focused on a core function of the platform: 

1. **User Service**:

2. **Hotel Service**: Act as the source of truth for all static hotel and room type metadata.

3. **Inventory Service**: Act as the single source of truth for real-time room availability and allocation.

4. **Pricing Service**: 

5. **Search Service**: Act as the central orchestrator for hotel discovery by combining hotel metadata, real-time room availability, and latest pricing.

6. **Reservation Service**:

7. **Payment Service**:

8. **Notification Service**:

Let's discuss the **API design** of the core services in detail, covering key aspects such as main endpoints, request and response structures, underlying business logic, and estimated load expectations.

---
### Search Service

Enable customers to find hotels by providing a **destination** and **travel dates**. Key endpoints include:

#### <span style="color:purple">1. GET /search/hotels?destination=...&check-in-date=...&check-out-date=...</span>

Use this endpoint to fetch the list of hotels that have at least one bookable room for the selected query parameters: `destination`, `check-in-date`, and `check-out-date`.

##### <span style="color:green;">Request Body (Sample)</span>

```
It accepts no request body.
```

##### <span style="color:green;">Response Body (Sample)</span>

```
[
  {
    "hotel_id": 101,
    "hotel_name": "Grand Goa Resort",
    "address": "Candolim Beach Road, Goa, India",
    "thumbnail_url": "https://cdn.example.com/101/thumb.jpg",
    "star_rating": 4,
    "lowest_price_per_night": 4500.0,
  },
  {
    "hotel_id": 102,
    "hotel_name": "City Budget Inn",
    "address": "MG Road, Bengaluru, India",
    "thumbnail_url": "https://cdn.example.com/102/thumb.jpg",
    "star_rating": 3,
    "lowest_price_per_night": 2200.0,
  }
]
```

##### <span style="color:green;">Business Logic (Pseudo Code)</span>

The `SearchService` will extract all the query parameters: `destination`, `check-in-date` and `check-out-date`, and delegate the request to the `search(destination, checkInDate, checkOutDate)` method.

```
public List<AvailableHotelSummary> search(String destination, 
											LocalDate checkInDate, 
											LocalDate checkOutDate) {

        List<AvailableHotelSummary> availableHotelSummaries = new ArrayList<>();
        
        /*
         * Step 1: Fetch hotel metadata for the given destination
         * Step 2: Query room availability across travel dates
         * Step 3: Calculate lowest average per-night price for each hotel   
         */
         
        return availableHotelSummaries;
        
    }
```

Let's walkthrough each step in detail to understand how the `SearchService` interacts with `HotelService`, `InventoryService` and `PricingService` to serve a search request:

###### Step 1: Fetch hotel metadata for the given destination

Call the `HotelService` to retrieve a list of hotels matching the `destination`. This provides static attributes like hotel `name`, `address`, `thumbnailUrl`, `starRating` etc.

```
List<Hotel> hotels = hotelServiceClient.getHotelsByDestination(destination);
```

###### Step 2: Query room availability across travel dates

Call the `InventoryService` to find which room types are available across the entire date range `[checkInDate, checkOutDate)`. This ensures we only consider hotels that can actually accommodate the request.

```
List<String> hotelIds = hotels.stream().map(Hotel::getId).toList();
List<AvailableRoomType> availableRoomTypes = inventoryServiceClient
            .getAvailableRoomTypes(hotelIds, checkInDate, checkOutDate));
```

###### Step 3: Calculate lowest average per-night price for each hotel and build response

Call the `PricingService` for each available `{hotelId, roomTypeId}` pair to fetch prices, compute the average per-night price across the stay, select the lowest among them, and assemble an `AvailableHotelSummary` with the hotel’s static details and the chosen price.

```
Map<String, Hotel> hotelById = hotels.stream()
	.collect(Collectors.toMap(Hotel::getId, hotelObj -> hotelObj));

Map<String, List<AvailableRoomType>> grouped = availableRoomTypes.stream()
    .collect(Collectors.groupingBy(AvailableRoomType::getHotelId));

 for(String hotelId : grouped.keySet()) {
    Hotel hotel = hotelById.get(hotelId);
    AvailableHotelSummary hotelSummary = new AvailableHotelSummary(hotel);
    
    for(AvailableRoomType availableRoomType : grouped.get(hotelId) ) {
        List<Double> priceList = pricingServiceClient.getPrice(
            availableRoomType.getHotelId(), 
            availableRoomType.getRoomTypeId(), 
            checkInDate, 
            checkOutDate
        );
        
        double price = priceList.stream()
	        .mapToDouble(Double::doubleValue).sum() / priceList.size(); 
	     
        hotelSummary.setLowestPrice(
	        Math.min(hotelSummary.getLowestPrice(), price));
    }
    
    availableHotelSummaries.add(hotelSummary);
}
```

##### <span style="color:green;">Load Estimation</span>

```
- Assumption: Daily Active Users (DAU) = 5 Million
- Assumption: Average Search Requests per User per Day = 5

- Total Requests per Day = 5M * 5 = 25M
- Average RPS = 25,000,000 / (86,400) ≈ 250 RPS

- Assumption: Peak Load Factor = 5x
- Peak RPS = 250 * 5 ≈ 1,250 RPS
```

#### <span style="color:red">Design Choice</span>

---
### Hotel Service

Enable customers to discover and evaluate hotels by providing access to all the static metadata they need before making a reservation. Key endpoints include:

#### <span style="color:purple;font-weight:bold">1. GET /hotels?destination=... (public)</span>

Used by `SearchService` to get candidate hotels for a `destination`.

##### <span style="color:green;">Request Body (Sample)</span>

```
It accepts no request body
```

##### <span style="color:green;">Response Body (Sample)</span>

```
[
  {
    "id": 101,
    "name": "Grand Goa Resort",
    "description": "A luxury seaside resort offering modern rooms, infinity 
				    pool, and beach access.",
    "location_id": "GOA",
    "address": "Candolim Beach Road, Goa, India",
    "thumbnail_url": "https://cdn.example.com/101/thumb.jpg",
    "customer_rating": 4.6,
    "star_rating": 4,
    "amenities": ["wifi", "pool", "gym", "spa"]
  },
  {
    "id": 102,
    "name": "Westin Resort",
    "description": "Premium 5-star property featuring private beach, fine 
					dining, and wellness spa.",
    "location_id": "GOA",
    "address": "Arpora Beach Road, Goa, India",
    "thumbnail_url": "https://cdn.example.com/102/thumb.jpg",
    "customer_rating": 4.7,
    "star_rating": 5,
    "amenities": ["wifi", "pool", "private beach", "restaurant", "bar"]
  }
]
```

##### <span style="color:green;">Business Logic (Pseudo Code)</span>

The `HotelService` will extract the query parameter: `destination` and delegate the request to the `getHotels(destination)` method.

 The `gethotel()` method resolves the `destination` to an internal `locationId (for example, mapping "Goa" → "GOA")`, queries the `HotelRepository (DB)` to fetch all hotels mapped to that location and return the results as a list of hotel records to the `SearchService`.

```
public List<Hotel> getHotels(String destination) {
	String locationId = LocationRepository.getLocationIdByName(destination);
	return HotelRepository.getHotelsByLocationId(locationId);
}
```

##### <span style="color:green;">Load Estimation</span>

Since this endpoint is primarily invoked by the `SearchService` when handling hotel search requests, its expected load will mirror that of the `GET /search/hotels` endpoint in the `SearchService`.

```
- Average RPS = 250 RPS
- Peak RPS = 1,250 RPS
```

#### <span style="color:purple;font-weight:bold">2. GET /hotel/{id}</span>

Use this endpoint to fetch the details of a specific hotel selected by the customer.

**Request Body (Sample)**

```

```

**Business Logic (Pseudo Code)**

```

```

**Response Body (Sample)**

```

```

**Load Estimation**

```
- Assumption: 50% of users view details after search
- Assumption: Average View Details Requests per User per Day = 2

- Total Requests per Day = 5M * 50% * 2 = 5,000,000
- Average RPS = 5,000,000 / (86,400) ≈ 50 RPS

- Assumption: Peak Load Factor = 5x
- Peak RPS = 50 * 5 ≈ 250 RPS
```

<span style="color:red;">Caching Strategy</span>

Because the `HotelService` only returns static metadata (which is relatively small and stable), these calls are lightweight and well-suited for caching at multiple layers (e.g., Redis, CDN, or client-side caching).

---
### Inventory Service

The Inventory Service acts as the system’s source of truth for room availability, ensuring accurate and up-to-date tracking of hotel capacity across dates. 

It manages the allocation of rooms by hotel and room type, enforces business rules such as ensuring continuous availability across a stay, and supports both search queries and reservation workflows.

Key endpoints include:

<span style="color:purple;font-weight:bold;">1. POST /v1/inventory/query</span>

Use this endpoint to fetch list of room types that have continuous availability for the requested date range for multiple hotels.

> **NOTE:** Availability checks often need dozens or even hundreds of `hotelIds` at once. With `GET` request, you’d have to pass them as query params. 
> 
> URLs have length limits (practically 2–4 KB), which can break large requests. `POST` request lets you send a `JSON` body with an arbitrary number of `hotelIds`, cleanly and safely.

<span style="color:green;font-weight:bold">Request Body (Sample)</span>

```
{
  "hotelIds": [101, 102, 103],
  "checkIn": "2025-10-01",
  "checkOut": "2025-10-05"
}
```

<span style="color:green;font-weight:bold;">Business Logic</span>

```

```

<span style="color:green;font-weight:bold;">Response Body (Sample)</span>

```

```

<span style="color:green;font-weight:bold;">Load Estimation</span>

```

```

---

```
Inventory SQL: find hotel_ids that have at least one room_type fully available for the full date range
```

```
- Step 1: pre-filter hotels by location (from hotels table)
- Step 2: find room_type that is available for the entire date range.
```

The `updated_at` timestamp lets the system know when a record was last modified, which helps detect stale data (e.g., if a cache is older than the DB value). 

Additionally, during booking, the system might compare the `updated_at` timestamp to ensure the record hasn’t changed since it was fetched. This supports optimistic locking, preventing double bookings or using outdated prices.

---
### Pricing Service

---
### Reservation Service

Book a Hotel Room

<span style="color:purple;font-weight:bold">Sample Request Body</span>

<span style="color:purple;font-weight:bold">Business Logic</span>

<span style="color:purple;font-weight:bold">Sample Response Body</span>

<span style="color:purple;font-weight:bold">Load Estimation</span>

```
- Assumption: 2% of users make a booking per day
- Assumption: Average Booking Requests per User per Day = 1

- Total Requests per Day = 5M * 2% = 100,000
- Average RPS = 100,000 / (24 * 60 * 60) ≈ 1 RPS

- Assumption: Peak Load Factor = 5x
- Peak RPS = 1 * 5 = 5 RPS
```


---
### EXTRA

`InventoryService` primary use case is to answer two critical questions at any moment:

1. Is this room type actually available for these dates?
2. Can I safely lock this room for a customer until they finish booking?


```
    inventoryResp = InventoryAPI.query({
      hotel_ids: hotelIds,
      check_in_date: checkIn,
      check_out_date: checkOut
    })
    // inventoryResp.results: [{hotel_id, available:bool, room_types: [{room_type_id, available_rooms, as_of, stale}, ...]}, ...]

    // 4. filter hotels that have at least one available room type
    availableHotels = []
    for each hotel in hotels:
        inv = find(inventoryResp.results, r => r.hotel_id == hotel.hotel_id)
        if inv is null or inv.available == false:
            continue
        availableRoomTypes = inv.room_types.filter(rt => rt.available_rooms > 0).map(rt => rt.room_type_id)
        if availableRoomTypes is empty:
            continue
        availableHotels.append({ hotel: hotel, roomTypeIds: availableRoomTypes, invMeta: inv })

    if availableHotels is empty:
        return { results: [] }

    // 5. get pricing for each hotel's available room types
    results = []
    for each item in availableHotels:
        pricingReq = {
          hotel_id: item.hotel.hotel_id,
          room_type_ids: item.roomTypeIds,
          check_in_date: checkIn,
          check_out_date: checkOut
        }
        pricingResp = PricingAPI.quote(pricingReq)
        // pricingResp.items: [{room_type_id, total_price, currency, price_version, as_of, stale}, ...]

        if pricingResp failed or pricingResp.items is empty:
            // Option: skip hotel or mark price unavailable; here we skip
            continue

        // 6. compute lowest price for hotel
        lowest = min(pricingResp.items, by = total_price)
        results.append({
           hotel_id: item.hotel.hotel_id,
           name: item.hotel.name,
           thumbnail: item.hotel.thumbnail,
           lowest_price: { amount: lowest.total_price, currency: lowest.currency },
           price_version: lowest.price_version,
           as_of: mergeTimestamps(item.invMeta.as_of, lowest.as_of),
           stale: item.invMeta.stale OR lowest.stale
        })

    // 7. return assembled list (no ranking/limits applied here)
    return { as_of: now(), results: results }

```

**User Service** <span style="color:purple;font-weight:bold">Load Estimation</span>: handle sign up requests

```
- Assumption: Daily Active Users (DAU) = 5 Million
- Assumption: 20% of DAU log in per day

- Total Requests per Day = 5M * 20% = 1M
- Average RPS = 1,000,000 / (24 * 60 * 60) ≈ 10 RPS

- Assumption: Peak Load Factor = 5x
- Peak RPS = 10 * 5 ≈ 50 RPS
```

> Design Choice: Keep IAM API (for sign in and api requests) separate from User API

---
