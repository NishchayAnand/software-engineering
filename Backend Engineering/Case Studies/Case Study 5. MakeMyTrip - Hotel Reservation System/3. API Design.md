
The **Hotel Reservation System** can be organized into the following services, each focused on a core function of the platform: 

1. **User Service**:

2. **Hotel Service**: Act as the source of truth for all static hotel and room type metadata.

3. **Inventory Service**: Act as the single source of truth for real-time room availability and allocation.

4. **Pricing Service**: 

5. **Search Service**: Act as the central orchestrator for hotel discovery by combining hotel metadata, real-time room availability, and latest pricing.

6. **Reservation Service**:

7. **Payment Service**:

8. **Notification Service**:

Let's discuss the **API design** of the core services in detail, covering key aspects such as main endpoints, request and response structures, underlying business logic, and estimated load expectations.

---
### Search Service

Enable customers to find hotels by providing a **destination** and **travel dates**. Key endpoints are:

<span style="color:purple;font-weight:bold">GET /search/hotels?destination=...&check-in-date=...&check-out-date=...</span>

Use this endpoint to fetch the list of hotels that have at least one bookable room for the selected query parameters: `destination`, `check-in-date`, and `check-out-date`.

**Request Body (sample)**

```
It accepts no request body.
```

**Business Logic (Pseudo Code)**

```
public List<HotelSearchResult> searchHotels(destination, checkIn, checkOut):

    // Step 1: Fetch hotel metadata for destination
    List<Hotel> hotels = HotelAPI.getHotels(destination);

    // Step 2: Query inventory for availability across the date range
    List<Integer> hotelIds = hotels.map(hotel -> hotel.getId());
    List<InventoryRecord> availableInventory = 
			     InventoryAPI.getAvailability(hotelIds, checkIn, checkOut);
     
	// Step 3: Get lowest price for each available hotel
	Map<Integer, Integer> pricingMap = {}; {hotelId, lowestPrice}
	for( InventoryRecord record: availableInventory ):
		int price = pricingService.getPrice(record.getHotelId(), 
											record.getHotelRoomType(),
											checkIn);
		if pricingMap.contains( record.getHotelId() ):
			pricingMap.put(record.getHotelId(), 
							min( pricingMap.get(record.getHotelId()), price );
		else:
			pricingMap.put(record.getHotelId(), price);	
		
	// Step 4: Collate result
	List<HotelSearchResult> results = [];
	for( Integer hotelId: pricingMap.keySet()):
		HotelSearchResult result = new HotelSearchResult(
			hotelId, 
		);
		results.add(result);
		
	return results;
```

**Response Body (Sample)**

```
[
	{
      "hotel_id": 101,
      "name": "Grand Goa Resort",
      "thumbnail": "https://cdn.example.com/101/thumb.jpg",
      "lowest_price": 4500.0
    },
    {
      "hotel_id": 102,
      "name": "City Budget Inn",
      "thumbnail": "https://cdn.example.com/102/thumb.jpg",
      "lowest_price": 2200.0
    }
]
```

**Load Estimation**

```
- Assumption: Daily Active Users (DAU) = 5 Million
- Assumption: Average Search Requests per User per Day = 5

- Total Requests per Day = 5M * 5 = 25M
- Average RPS = 25,000,000 / (86,400) ≈ 250 RPS

- Assumption: Peak Load Factor = 5x
- Peak RPS = 250 * 5 ≈ 1,250 RPS
```

<span style="color:green;font-weight:bold">Design Choice</span>



---
### Hotel Service

Enable customers to discover and evaluate hotels by providing access to all the static metadata they need before making a reservation. Key endpoints include:

<span style="color:purple;font-weight:bold">GET /hotels?destination=...</span>

Use this endpoint to fetch the list of hotels in a specific `destination`.

**Request Body (Sample)**

```
It accepts no request body
```

**Business Logic (Pseudo Code)**

```
public List<Hotel> getHotels(String destination):
	return HotelRepository.getHotelsByDestination(destination);
```

**Response Body (Sample)**

```
[
    {
      "hotelId": 101,
      "name": "Grand Goa Resort",
      "locationId": "GOA",
      "thumbnailUrl": "https://cdn.../101/thumb.jpg",
      "rating": 4.6,
      "starRating": 4,
      "amenities": ["wifi","pool"]
    }
]
```

**Load Estimation**

Will only be called by the search service's `searchHotel()` function. Hence, load under normal and peak condition would be same as that of the search service.

```
- Average RPS = 250 RPS
- Peak RPS = 1,250 RPS
```

<span style="color:purple;font-weight:bold">GET /hotel/{hotel_id}</span>

Use this endpoint to fetch the details of a specific hotel selected by the customer.

**Request Body (Sample)**

```

```

**Business Logic (Pseudo Code)**

```

```

**Response Body (Sample)**

```

```

**Load Estimation**

```
- Assumption: 50% of users view details after search
- Assumption: Average View Details Requests per User per Day = 2

- Total Requests per Day = 5M * 50% * 2 = 5,000,000
- Average RPS = 5,000,000 / (86,400) ≈ 50 RPS

- Assumption: Peak Load Factor = 5x
- Peak RPS = 50 * 5 ≈ 250 RPS
```

<span style="color:purple;font-weight:bold">GET /v1/hotels/{hotelId}/room-types</span>

Return the room type definitions for a hotel.

**Request Body (Sample)**

```

```

**Business Logic (Pseudo Code)**

```

```

**Response Body (Sample)**

```

```

**Load Estimation**

```

```

<span style="color:green;font-weight:bold">Design Choice</span>


---
### Inventory Service

Its primary use case is to answer two critical questions at any moment:

1. Is this room type actually available for these dates?
2. Can I safely lock this room for a customer until they finish booking?

```
Inventory SQL: find hotel_ids that have at least one room_type fully available for the full date range
```

```
- Step 1: pre-filter hotels by location (from hotels table)
- Step 2: find room_type that is available for the entire date range.
```

The `updated_at` timestamp lets the system know when a record was last modified, which helps detect stale data (e.g., if a cache is older than the DB value). 

Additionally, during booking, the system might compare the `updated_at` timestamp to ensure the record hasn’t changed since it was fetched. This supports optimistic locking, preventing double bookings or using outdated prices.

---
### Rate Service

will handle discounts also

---
### Reservation Service

Book a Hotel Room

<span style="color:purple;font-weight:bold">Sample Request Body</span>

<span style="color:purple;font-weight:bold">Business Logic</span>

<span style="color:purple;font-weight:bold">Sample Response Body</span>

<span style="color:purple;font-weight:bold">Load Estimation</span>

```
- Assumption: 2% of users make a booking per day
- Assumption: Average Booking Requests per User per Day = 1

- Total Requests per Day = 5M * 2% = 100,000
- Average RPS = 100,000 / (24 * 60 * 60) ≈ 1 RPS

- Assumption: Peak Load Factor = 5x
- Peak RPS = 1 * 5 = 5 RPS
```


---
### EXTRA

```
    inventoryResp = InventoryAPI.query({
      hotel_ids: hotelIds,
      check_in_date: checkIn,
      check_out_date: checkOut
    })
    // inventoryResp.results: [{hotel_id, available:bool, room_types: [{room_type_id, available_rooms, as_of, stale}, ...]}, ...]

    // 4. filter hotels that have at least one available room type
    availableHotels = []
    for each hotel in hotels:
        inv = find(inventoryResp.results, r => r.hotel_id == hotel.hotel_id)
        if inv is null or inv.available == false:
            continue
        availableRoomTypes = inv.room_types.filter(rt => rt.available_rooms > 0).map(rt => rt.room_type_id)
        if availableRoomTypes is empty:
            continue
        availableHotels.append({ hotel: hotel, roomTypeIds: availableRoomTypes, invMeta: inv })

    if availableHotels is empty:
        return { results: [] }

    // 5. get pricing for each hotel's available room types
    results = []
    for each item in availableHotels:
        pricingReq = {
          hotel_id: item.hotel.hotel_id,
          room_type_ids: item.roomTypeIds,
          check_in_date: checkIn,
          check_out_date: checkOut
        }
        pricingResp = PricingAPI.quote(pricingReq)
        // pricingResp.items: [{room_type_id, total_price, currency, price_version, as_of, stale}, ...]

        if pricingResp failed or pricingResp.items is empty:
            // Option: skip hotel or mark price unavailable; here we skip
            continue

        // 6. compute lowest price for hotel
        lowest = min(pricingResp.items, by = total_price)
        results.append({
           hotel_id: item.hotel.hotel_id,
           name: item.hotel.name,
           thumbnail: item.hotel.thumbnail,
           lowest_price: { amount: lowest.total_price, currency: lowest.currency },
           price_version: lowest.price_version,
           as_of: mergeTimestamps(item.invMeta.as_of, lowest.as_of),
           stale: item.invMeta.stale OR lowest.stale
        })

    // 7. return assembled list (no ranking/limits applied here)
    return { as_of: now(), results: results }

```

**User Service** <span style="color:purple;font-weight:bold">Load Estimation</span>: handle sign up requests

```
- Assumption: Daily Active Users (DAU) = 5 Million
- Assumption: 20% of DAU log in per day

- Total Requests per Day = 5M * 20% = 1M
- Average RPS = 1,000,000 / (24 * 60 * 60) ≈ 10 RPS

- Assumption: Peak Load Factor = 5x
- Peak RPS = 10 * 5 ≈ 50 RPS
```

> Design Choice: Keep IAM API (for sign in and api requests) separate from User API

---
