
The **data model** of the **Hotel Reservation System** can be organized around the following entities:

1. **Hotel**: Represents the static information about each hotel.

2. **Room**: Defines the different categories of rooms within a hotel.

3. **Room_Type_Inventory**: Stores per-room-type, per-date availability.

4. **Room_Type_Rate**: Manages per-room-type, per-date dynamic or personalized pricing.

5. **Reservation**: Represents confirmed customer bookings.

Let’s discuss the core entities in detail, focusing on the queries they need to fulfill, the expected growth in data over a 10-year horizon, and the partitioning and storage strategies required to ensure scalability and performance.

---
### Hotel

The **Hotel** entity serves as the master record for each registered hotel, providing static information customers need to discover and evaluate hotels before making a reservation. 

#### <span style="color:green;font-weight:bold;">Schema</span>

| Field       | Approx. Size | Description                                          |
| ----------- | ------------ | ---------------------------------------------------- |
| hotel_id    | ~16 bytes    | Unique identifier (UUID or numeric ID)               |
| name        | ~50 bytes    | Hotel name (typically under 50 characters)           |
| location_id | ~3 bytes     | Location reference (mapped to city or region)        |
| address     | ~100 bytes   | Full address (typically under 100 characters)        |
| description | ~200 bytes   | Text description of the hotel (up to 200 characters) |
| amenities   | ~500 bytes   | List of amenities, e.g., Wi-Fi, Pool (~10 items)     |
| rating      | ~4 bytes     | Usually 1–5 stars with one decimal place, like 4.3   |

#### <span style="color:green;font-weight:bold;">Indexing Strategy</span>

Since every hotel search begins with a destination, queries such as `SELECT * FROM hotel WHERE location_id = ?` would typically trigger a sequential scan of the entire hotel table, forcing the database to check every row. At scale, this leads to unnecessary I/O, unpredictable spikes, and slow responses during peak load. 

Because search endpoints demand low and consistent latency, a B-tree index on `location_id` can be introduced to allow the database to directly locate the relevant rows through index lookups, eliminating the need for full table scans and drastically improving query performance.

```
CREATE INDEX idx_hotel_location ON hotel(location_id);
```

#### <span style="color:green;font-weight:bold;">Storage Estimation</span>

```
- Assumption: Total Hotels = 1 Million
- Average Hotel Record Size = 1 KB (with indexes)
- Total Storage for Hotels = 1,000,000 × 1 KB = 1 GB
```

#### <span style="color:green;font-weight:bold;">Partitioning Strategy</span>

Even with `1 Million` hotels over `10-year` horizon, the dataset would only occupy `1 GB`. Because of its modest size and static nature, partitioning is unnecessary.

---
### Room_Type_Inventory

The **Room_Type_Inventory** entity serves as the authoritative source for tracking daily room availability for each room type within a hotel. It ensures accurate availability checks during search and booking operations.

It is utilized to check if a customer can reserve a specific type of room or not.

<span style="color:green;font-weight:bold;">Schema</span>

| Field        | Approx. Size | Description                                 |
| ------------ | ------------ | ------------------------------------------- |
| hotel_id     | ~16 bytes    | Reference to the hotel                      |
| room_type_id | ~16 bytes    | Reference to the room type                  |
| date         | ~8 bytes     | Calendar date (daily granularity)           |
| total_rooms  | ~4 bytes     | Total rooms of this type the hotel operates |
| reserved     | ~4 bytes     | Rooms already reserved for the date         |
| updated_at   | ~8 bytes     | Timestamp of the last inventory update      |

<span style="color:green;font-weight:bold;">Indexing Strategy</span>

Search and booking flows frequently require filtering inventory by `hotel_id`, `room_type_id`, and `date`. Without indexes, these queries would degrade into sequential scans across millions of rows, especially when checking multi-day availability. 

By creating a composite B-tree index on (`hotel_id`, `room_type_id`, `date`), the database can efficiently locate availability records and ensure fast range scans for booking windows.

```
CREATE INDEX idx_inventory_lookup ON room_type_inventory(hotel_id, room_type_id, date);
```

<span style="color:green;font-weight:bold;">Storage Estimation</span>

```
- Assumptions: 
	- Total Hotels = 1 Million
	- Avg Room Types per Hotel = 3 (Standard, Deluxe, Suite)
	  
- Rows per year = 1,000,000 x 3 x 365 ~ 1,200,000,000 = 1.2 Billion
- Avg Row Size = 50 bytes
  
- Total Storage for 10-Year Horizon = 10 x 1,200,000,000 x 50 bytes
									= 600,000,000,000 = 0.6 TB
```

<span style="color:green;font-weight:bold;">Partitioning Strategy</span>

Can shard by `hotelId`.

Most queries touch a small date range (e.g., next 30–90 days). If the dataset is partitioned by month, system will only scan the partitions whose date ranges overlap the query, dramatically reducing I/O.

 Keep recent partitions (the next 6–8 months) on fast writable storage (hot storage) and tune those partitions for low-latency reads/writes. This is where most searches and bookings will hit. 
 
 Older partitions outside the hot window are rarely accessed for live bookings and can be archived off the primary DB to cheaper storage.

<span style="color:red;">EXTRA</span>

The `updated_at` timestamp lets the system know when a record was last modified, which helps detect stale data (e.g., if a cache is older than the DB value). 

Additionally, during booking, the system might compare the `updated_at` timestamp to ensure the record hasn’t changed since it was fetched. This supports optimistic locking, preventing double bookings or using outdated prices.

`(hotel_id, room_type_id, date)` is the composite primary key. The rows of the table are pre-populated by querying the inventory data across all future dates within 2 years. <span style="color:red;">(explore this)</span>. <span style="color:green;font-weight:bold;background:beige;">We can have a daily job that pre-populates inventory data when the dates advance further.</span>

**Query 1: Select rows within a date range**

```
SELECT date, total_inventory, total_reserved
FROM room_type_inventory
WHERE room_type_id = ${room_type_id} AND hotel_id = ${hotelId} AND date BETWEEN ${checkInDate} and ${checkOutDate}
```

---
### Room_Type_Rate

The **Room_Type_Rate** entity manages pricing information for each room type on each date. It provides base rates for search results and detailed rate breakdowns for checkout validation.

<span style="color:green;font-weight:bold;">Schema</span>

| Field        | Approx. Size | Description                        |
| ------------ | ------------ | ---------------------------------- |
| hotel_id     | ~16 bytes    | Reference to the hotel             |
| room_type_id | ~16 bytes    | Reference to the room type         |
| date         | ~8 bytes     | Date of the rate                   |
| base_price   | ~8 bytes     | Base room price (numeric)          |
| updated_at   | ~8 bytes     | Timestamp of the last price update |

<span style="color:green;font-weight:bold;">Indexing Strategy</span>

Since price lookups typically happen alongside availability checks, efficient access by (`hotel_id`, `room_type_id`, `date`) is critical. 

A composite B-tree index ensures quick retrieval of rates for search results and booking flows, while also enabling consistency checks during reservation finalization.

```
CREATE INDEX idx_rate_lookup ON room_type_rate(hotel_id, room_type_id, date);
```

<span style="color:green;font-weight:bold;">Storage Estimation</span>

```
- Assumptions: 
	- Total Hotels = 1 Million
	- Avg Room Types per Hotel = 3 (Standard, Deluxe, Suite)
	  
- Rows per year = 1,000,000 x 3 x 365 ~ 1,200,000,000 = 1.2 Billion
- Avg Row Size = 50 bytes
  
- Total Storage for 10-Year Horizon = 10 x 1,200,000,000 x 50 bytes
									= 600,000,000,000 = 0.6 TB
```

<span style="color:green;font-weight:bold;">Partitioning Strategy</span>

Rates are time-series data, so partitioning by date is essential to maintain query performance. Like inventory, recent partitions remain in hot storage, while older rates can be archived or recalculated on demand from pricing rules.

Can shard by `hotelId`.

<span style="color:red;font-weight:bold;">Follow Up</span>

Inventory is the authoritative availability ledger — counts of rooms that can be reserved — while rates are the authoritative pricing ledger — base rates, discounts, and pricing rule snapshots. 

They change at different frequencies, have different transactional requirements (inventory updates must support atomic holds/confirmations; pricing needs versioning and rule evaluation), and are typically owned and evolved by different teams/services. 

Keeping them separate enforces separation of concerns, simplifies correctness for booking flows, and lets you scale and optimize each table independently. 

You can still colocate a price snapshot on the inventory row for fast search results, without making the pricing engine lose its authoritative role.

---
### Reservation

This entity represents the transactional data that links a user to a specific room in a hotel for a defined date range.

```
- reservation_id:
- request_id: 
- User ID: ~16 bytes (UUID or numeric ID)
- Hotel ID: ~16 bytes
- Room ID: ~16 bytes
- Dates: ~32 bytes (check-in and check-out dates)
- Payment status: ~20 bytes (e.g., “Paid”, “Pending”)
- Other Attributes: ~500 bytes (created timestamp, updated timestamp, etc.)
```

Since booking records are transactional in nature, they are most frequently queried within the first **12 months** (for cancellations, modifications, customer support, disputes, etc.). After this retention window, the likelihood of accessing historical bookings drops significantly.

```
- Assumption: Daily Bookings = 100,000 (from load estimation)
- Assumption: Booking Retention = 1 year (365 days)
- Total Bookings per Year = 100,000 * 365 = 36.5 Million
- Booking Record Size = 1 KB (with indexes & overhead)
- Total Storage for Bookings = 36,500,000 * 1 KB = 36.5 GB
```

> **NOTE:** To optimize performance and reduce storage costs, move older bookings from the **OLTP (Online Transaction Processing) database** to an **OLAP (Online Analytical Processing) database**.

<span style="color:red;">Design Choice</span>

A relational database provides ACID (atomicity, consistency, isolation, durability). ACID properties are important for the reservation system. 

ACID properties make the application code a lot simpler and make the whole system easier to reason about.

---

To model the "search hotels" workflow for a hotel reservation system, a suitable ER diagram could include entities such as User, Search, Hotel, Room, Location, and Amenities. The relationships would capture that a User performs a Search, Search returns Hotels (in a Location), Hotels have Rooms and Amenities, and availability is checked.

Here's a summary of the ER diagram:

- User performs Searches
- Each Search can return multiple Hotels (filtered by Location, dates, etc.)
- Hotel has many Rooms
- Hotels and Rooms can have Amenities
- Room has Availability for a date range

---
### Storage Estimation

Designing a scalable system requires a clear understanding of how much data the platform needs to store and manage over time. **Storage estimation** helps us anticipate database size, plan for indexing, implement backup strategies, and decide whether to adopt **sharding or archiving** for future growth. 

Let's estimate the storage requirements for key entities:

---
### Room

If rooms were stored as an **embedded list inside the Hotel entity**, updating a single room (e.g., changing its availability or price) would require **updating the entire hotel record**. This could lead to **write conflicts** and require **locking the whole hotel record**, reducing performance under high load. 

By keeping **Room** as a separate entity, each room can be updated independently, minimising lock contention and improving **scalability**, **performance**, and **concurrency handling**.

```
- Room ID: ~16 bytes (UUID or numeric ID)
- Room Type: ~100 bytes (e.g., "Deluxe", "Standard")  
- Price: ~50 bytes (price value + currency)  
- Availability: ~250 bytes (calendar)  
- Other Attributes: ~500 bytes (bed type, occupancy, amenties, etc.)
```

```
- Assumption: Average Rooms per Hotel = 100
- Average Room Record Size = 1 KB (with indexes & overhead)  
- Total Storage for Rooms = 1,000,000 * 100 * 1 KB = 100 GB
```

---

<span style="color:green;font-weight:bold">Summary</span>

| **Entity**       | **Estimated Size per Record** | **Total Records** | **Total Storage** |
| ---------------- | ----------------------------- | ----------------- | ----------------- |
| **Hotels**       | 5 KB                          | 1,000,000         | 5 GB              |
| **Hotel Images** | 500 KB                        | 10,000,000        | 5 TB              |
| **Rooms**        | 1 KB                          | 100,000,000       | 100 GB            |
| **Users**        | 1 KB                          | 50,000,000        | 50 GB             |
| **Bookings**     | 1 KB                          | 36,500,000        | 36.5 GB           |

---
### EXTRA

<span style="color:purple;font-weight:bold">Users</span>

This entity forms the basis for identity management, personalization, and secure access across the platform.

```
- User ID: ~16 bytes (UUID or numeric ID)
- Name: ~100 bytes (First Name + Last Name)
- Email: ~100 bytes (can be long, e.g., corporate emails)
- Phone Number: ~20 bytes (include country code + separators)
- Hashed Password: ~256 bytes (depending on algorithm)
- Other Attributes: ~500 bytes (profile image URL, addresses, preferences, etc.)
```

```
- (Assumption) Total Registered Users: 50 Million
- Average User Record Size: 1 KB (with indexes & overhead)
- Total Storage = 50,000,000 * 1 KB = 50,000,000 KB = 50 GB
```

---
### Hotel Entity

Indexing on Rating:

```
CREATE INDEX idx_hotel_rating ON hotel(rating);
```