
The **data model** of the **Hotel Reservation System** can be organized around the following core entities:

1. **Hotel**: Represents the static information about each hotel.
2. **Room_Type**: Defines the different categories of rooms within a hotel.
3. **Inventory**: Stores per-room-type, per-date availability.
4. **Price**: Manages per-room-type, per-date dynamic or personalized pricing.
5. **Reservation**: Represents confirmed customer bookings.

Let’s discuss each of these entities in detail, focusing on the queries they need to fulfill, the expected growth in data over a 10-year horizon, and the partitioning and storage strategies required to ensure scalability and performance.

---
### Hotel Entity

The **Hotel entity** serves as the canonical static record for each registered hotel, providing the details customers need to discover and evaluate hotels before making a reservation. 

<span style="color:green;font-weight:bold;">Schema</span>

```
- hotel_id: ~16 bytes (UUID or numeric ID)
- name: ~100 bytes (typically under 50 characters)
- location_id: ~250 bytes (mapped to city)
- Address: (full address, city, state, country)  
- Description: ~2 KB (maximum 2,000 characters)
- Amenities: ~500 bytes (list of 10 amenities, e.g., “Wi-Fi, Pool”)
- Images Metadata: ~2 KB (10 image URLs, each ~200 bytes)
```

<span style="color:green;font-weight:bold;">Storage Estimation</span>

```
- Assumption: Total Hotels = 1 Million
- Average Hotel Record Size = 5 KB (with indexes & overhead)
- Total Storage for Hotels = 1,000,000 × 5 KB = 5 GB
```

```
Assuming each hotel has **10 images** and each image is around **500 KB**, the total storage required for storing all images would be: `1,000,000 × 10 × 500 KB = 5,000,000,000 KB = 5 TB`.
```

<span style="color:green;font-weight:bold;">Design Choice</span>

The table scales with the number of hotels (H) and remains relatively small: even with 50,000 hotels, the dataset would only occupy tens to a few hundred megabytes including indexes over a 10-year horizon. 

Because of its modest size and static nature, partitioning is unnecessary. It is sufficient to store this table in a transactional database, replicate or index its contents into Elasticsearch for efficient search, and maintain periodic backups or snapshots in object storage for recovery and auditing.

> The Hotel entity is small and stable, so it can live in a transactional DB. Images should go in object storage. For search, push hotel data into Elasticsearch. No partitioning is required.

---



To model the "search hotels" workflow for a hotel reservation system, a suitable ER diagram could include entities such as User, Search, Hotel, Room, Location, and Amenities. The relationships would capture that a User performs a Search, Search returns Hotels (in a Location), Hotels have Rooms and Amenities, and availability is checked.

Here's a summary of the ER diagram:

- User performs Searches
- Each Search can return multiple Hotels (filtered by Location, dates, etc.)
- Hotel has many Rooms
- Hotels and Rooms can have Amenities
- Room has Availability for a date range

---
### Inventory

Use single `inventory` table with columns: `hotel_id, room_type_id, date, total_inventory, reserved_qty, price_base`.

---
### Storage Estimation

Designing a scalable system requires a clear understanding of how much data the platform needs to store and manage over time. **Storage estimation** helps us anticipate database size, plan for indexing, implement backup strategies, and decide whether to adopt **sharding or archiving** for future growth. 

Let's estimate the storage requirements for key entities:

---
### Room

If rooms were stored as an **embedded list inside the Hotel entity**, updating a single room (e.g., changing its availability or price) would require **updating the entire hotel record**. This could lead to **write conflicts** and require **locking the whole hotel record**, reducing performance under high load. 

By keeping **Room** as a separate entity, each room can be updated independently, minimising lock contention and improving **scalability**, **performance**, and **concurrency handling**.

```
- Room ID: ~16 bytes (UUID or numeric ID)
- Room Type: ~100 bytes (e.g., "Deluxe", "Standard")  
- Price: ~50 bytes (price value + currency)  
- Availability: ~250 bytes (calendar)  
- Other Attributes: ~500 bytes (bed type, occupancy, amenties, etc.)
```

```
- Assumption: Average Rooms per Hotel = 100
- Average Room Record Size = 1 KB (with indexes & overhead)  
- Total Storage for Rooms = 1,000,000 * 100 * 1 KB = 100 GB
```

---
### Booking

This entity represents the transactional data that links a user to a specific room in a hotel for a defined date range.

```
- User ID: ~16 bytes (UUID or numeric ID)
- Hotel ID: ~16 bytes
- Room ID: ~16 bytes
- Dates: ~32 bytes (check-in and check-out dates)
- Payment status: ~20 bytes (e.g., “Paid”, “Pending”)
- Other Attributes: ~500 bytes (created timestamp, updated timestamp, etc.)
```

Since booking records are transactional in nature, they are most frequently queried within the first **12 months** (for cancellations, modifications, customer support, disputes, etc.). After this retention window, the likelihood of accessing historical bookings drops significantly.

```
- Assumption: Daily Bookings = 100,000 (from load estimation)
- Assumption: Booking Retention = 1 year (365 days)
- Total Bookings per Year = 100,000 * 365 = 36.5 Million
- Booking Record Size = 1 KB (with indexes & overhead)
- Total Storage for Bookings = 36,500,000 * 1 KB = 36.5 GB
```

> **NOTE:** To optimize performance and reduce storage costs, move older bookings from the **OLTP (Online Transaction Processing) database** to an **OLAP (Online Analytical Processing) database**.

---

<span style="color:green;font-weight:bold">Summary</span>

| **Entity**       | **Estimated Size per Record** | **Total Records** | **Total Storage** |
| ---------------- | ----------------------------- | ----------------- | ----------------- |
| **Hotels**       | 5 KB                          | 1,000,000         | 5 GB              |
| **Hotel Images** | 500 KB                        | 10,000,000        | 5 TB              |
| **Rooms**        | 1 KB                          | 100,000,000       | 100 GB            |
| **Users**        | 1 KB                          | 50,000,000        | 50 GB             |
| **Bookings**     | 1 KB                          | 36,500,000        | 36.5 GB           |

---
### EXTRA

<span style="color:purple;font-weight:bold">Users</span>

This entity forms the basis for identity management, personalization, and secure access across the platform.

```
- User ID: ~16 bytes (UUID or numeric ID)
- Name: ~100 bytes (First Name + Last Name)
- Email: ~100 bytes (can be long, e.g., corporate emails)
- Phone Number: ~20 bytes (include country code + separators)
- Hashed Password: ~256 bytes (depending on algorithm)
- Other Attributes: ~500 bytes (profile image URL, addresses, preferences, etc.)
```

```
- (Assumption) Total Registered Users: 50 Million
- Average User Record Size: 1 KB (with indexes & overhead)
- Total Storage = 50,000,000 * 1 KB = 50,000,000 KB = 50 GB
```

---
